<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#030711">
<link rel="manifest" id="dynamicManifest">
<title>BTC QUANT C++ ULTRA AGRESSIVA TURBO 5000C</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<style>
  :root {
    --bg: #030711;
    --panel: #070d19;
    --card: #0b111f;
    --text: #c9d7f2;
    --text-muted: #637599;
    --accent: #f7931a; 
    --buy: #00ff9d;
    --sell: #ff2a55;
    --border: #1a243f;
    --font-main: 'Inter', system-ui, -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', 'Consolas', monospace;
  }
  * { box-sizing: border-box; outline: none; }
  body { margin: 0; background: var(--bg); color: var(--text); font-family: var(--font-main); font-size: 15px; overflow: hidden; height: 100vh; }
  .layout { display: grid; grid-template-rows: 50px 1fr; height: 100vh; }
  header {
    background: var(--panel); padding: 0 16px; border-bottom: 1px solid var(--border);
    display: flex; gap: 16px; align-items: center; overflow-x: auto;
  }
  .logo { font-weight: 900; color: var(--accent); letter-spacing: 1px; font-style: italic; white-space: nowrap; margin-right: 10px;}
  .control-group { display: flex; align-items: center; gap: 8px; border-right: 1px solid var(--border); padding-right: 12px; height: 30px; white-space: nowrap; }
  label { color: var(--text-muted); font-size:13px; font-weight: 600; text-transform: uppercase; }
  select, input {
    background: #040812;
    border: 1px solid #1e2d4a;
    color: var(--text);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: 14px;
  }
  input:focus { border-color: var(--accent); }
  .chk-group { display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; color: #fff; font-weight: bold; font-size:13px;}
  .chk-group input { width: auto; margin: 0; cursor: pointer; }
  #status-indicator { font-weight: bold; font-size:13px; margin-left: auto; color: #666; }
  #price-box { 
    display: flex; align-items: center; gap: 4px; font-family: var(--font-mono); font-size: 14px; 
    font-weight: bold; margin-left: 10px; border-left: 1px solid var(--border); padding-left: 12px; 
  }
  #px-current { color: #fff; }
  #px-chg { font-size:13px; margin-left: 4px; }
  .up { color: var(--buy); }
  .dn { color: var(--sell); }
  main { display: grid; grid-template-columns: 1fr 360px; overflow: hidden; height: calc(100vh - 50px); }
  .charts-area { 
    display: grid; grid-template-rows: 1fr; 
    gap: 8px; 
    padding: 8px; background: #050a13;
  }
  .chart-box { 
    background: var(--card); border: 1px solid var(--border); border-radius: 4px; 
    position: relative; width: 100%; height: 100%; overflow: hidden; cursor: crosshair; 
  }
  .chart-label { position: absolute; top: 8px; left: 10px; font-size:12px; font-weight: bold; color: var(--text-muted); z-index: 10; pointer-events: none; }
  aside { 
    background: var(--panel); border-left: 1px solid var(--border); overflow-y: auto; padding: 0; 
    display: flex; flex-direction: column; 
    gap: 4px;
  }
  .panel-section { 
    padding: 12px; 
    background: var(--card); 
    border: 1px solid var(--border); 
    margin: 4px 4px 0 4px;
    border-radius: 4px;
  }
  .panel-section:last-child {
    flex-grow: 1;
    margin-bottom: 4px;
    padding-bottom: 12px;
  }
  .panel-header { font-size:13px; font-weight: 700; color: var(--accent); text-transform: uppercase; margin-bottom: 8px; display: flex; justify-content: space-between; align-items:center; }
  .metric-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .metric-box { background: #060a13; padding: 8px; border-radius: 4px; border: 1px solid #151f33; }
  .metric-label { font-size:12px; color: var(--text-muted); display: block; }
  .metric-val { font-family: var(--font-mono); font-size: 15px; font-weight: 600; color: #fff; }
  table { width: 100%; border-collapse: collapse; font-size:13px; }
  th { text-align: right; color: var(--text-muted); padding: 4px; border-bottom: 1px solid var(--border); }
  th:first-child { text-align: left; }
  td { text-align: right; padding: 5px 4px; border-bottom: 1px solid #121a2d; font-family: var(--font-mono); }
  td:first-child { text-align: left; }
  .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size:13px; }
  .input-row input { width: 110px; text-align: right; }
  .text-up { color: var(--buy); }
  .text-dn { color: var(--sell); }
  
  .aside-toggle {
    display: none;
    margin-left: auto;
    background: linear-gradient(135deg, #f7931a, #ff2a55);
    border: 1px solid #ffffff33;
    color: #fff;
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 600;
    padding: 4px 10px;
    border-radius: 999px;
    cursor: pointer;
    white-space: nowrap;
  }
  .aside-toggle:active {
    transform: scale(0.96);
  }

  .aside-mobile-header {
    display: none;
  }
  .aside-close {
    border: none;
    background: #ff2a55;
    color: #fff;
    font-weight: 700;
    font-size: 14px;
    width: 26px;
    height: 26px;
    border-radius: 999px;
    cursor: pointer;
  }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: #1a243f; }

  /* === NOVO MAPA DE CALOR HORIZONTAL COMPACTO === */
  .heatmap-container {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .heatmap-bar-container {
    position: relative;
    height: 20px;
    background: rgba(7, 13, 25, 0.8);
    border-radius: 10px;
    border: 1px solid var(--border);
    overflow: hidden;
  }
  .heatmap-gradient {
    height: 100%;
    background: linear-gradient(90deg, 
      #0011ff 0%, 
      #0062ff 16.5%, 
      #00a8ff 33%, 
      #00c7a7 49.5%, 
      #27e46d 66%, 
      #6cfca6 82.5%, 
      #ff8b8b 100%);
    width: 100%;
  }
  .heatmap-indicator {
    position: absolute;
    top: -2px;
    width: 3px;
    height: 24px;
    background: white;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.9), 0 0 12px rgba(247, 147, 26, 0.7);
    border-radius: 1.5px;
    z-index: 10;
    transition: left 0.3s ease-out;
  }
  .heatmap-labels {
    display: flex;
    justify-content: space-between;
    font-family: var(--font-mono);
    font-size: 9px;
    color: var(--text-muted);
    margin-top: 4px;
  }
  .heatmap-current {
    text-align: center;
    margin-top: 8px;
  }
  .sigma-value {
    font-family: var(--font-mono);
    font-size: 20px;
    font-weight: 800;
    background: linear-gradient(45deg, #f7931a, #ff2a55);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 2px;
    line-height: 1;
  }
  .sigma-label {
    font-size: 11px;
    color: var(--text-muted);
    display: block;
  }
  .sigma-distance {
    font-size: 10px;
    color: var(--text-muted);
    margin-top: 4px;
    font-weight: 600;
  }
  
  /* === RECOMENDA√á√ÉO C++ TURBO === */
  .recommendation-box {
    background: linear-gradient(135deg, #080e1b, #0b111f);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px;
    margin-top: 8px;
  }
  .recommendation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .recommendation-title {
    font-size: 14px;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
  }
  .recommendation-priority {
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 700;
    background: #ff2a55;
    color: white;
    padding: 2px 6px;
    border-radius: 999px;
  }
  .recommendation-action {
    font-size: 16px;
    font-weight: 800;
    text-align: center;
    margin: 10px 0;
    padding: 8px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    font-family: var(--font-mono);
  }
  .action-buy {
    color: var(--buy);
    border: 1px solid var(--buy);
    background: rgba(0, 255, 157, 0.1);
  }
  .action-sell {
    color: var(--sell);
    border: 1px solid var(--sell);
    background: rgba(255, 42, 85, 0.1);
  }
  .action-hold {
    color: var(--accent);
    border: 1px solid var(--accent);
    background: rgba(247, 147, 26, 0.1);
  }
  .recommendation-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 10px;
  }
  .detail-item {
    background: rgba(4, 8, 15, 0.5);
    padding: 6px;
    border-radius: 4px;
    border: 1px solid #1a243f;
  }
  .detail-label {
    font-size: 10px;
    color: var(--text-muted);
    display: block;
  }
  .detail-value {
    font-family: var(--font-mono);
    font-size: 13px;
    font-weight: 600;
    color: white;
  }
  .recommendation-explanation {
    margin-top: 10px;
    font-size: 11px;
    color: var(--text-muted);
    line-height: 1.4;
    padding: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    border-left: 3px solid var(--accent);
  }

  /* ============ MELHORIAS PARA O BOT√ÉO C++ ============ */
  .ai-fab:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px rgba(247, 147, 26, 0.8);
    transition: all 0.2s ease;
  }

  .ai-fab:active {
    transform: scale(0.95);
    transition: transform 0.1s;
  }

  /* Estilo para o bot√£o C++ quando ativo (di√°logo aberto) */
  .ai-fab.active {
    background: radial-gradient(circle at 30% 30%, #ff2a55, #f7931a 60%, #070d19 100%);
    box-shadow: 0 0 25px rgba(247, 147, 26, 0.9), 0 0 40px rgba(255, 42, 85, 0.5);
    border: 2px solid #ffffff;
    transform: scale(1.05);
  }

  /* Melhorias para o di√°logo */
  .ai-dialog {
    animation: slideIn 0.3s ease-out;
    max-height: 80vh;
    overflow-y: auto;
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Bot√£o de fechar melhorado */
  .ai-dialog-close {
    background: rgba(255, 42, 85, 0.2);
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
  }

  .ai-dialog-close:hover {
    background: rgba(255, 42, 85, 0.4);
    transform: scale(1.1);
  }

  /* Scrollbar personalizada para o di√°logo */
  .ai-dialog::-webkit-scrollbar {
    width: 6px;
  }

  .ai-dialog::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  .ai-dialog::-webkit-scrollbar-thumb {
    background: rgba(247, 147, 26, 0.5);
    border-radius: 3px;
  }

  .ai-dialog::-webkit-scrollbar-thumb:hover {
    background: rgba(247, 147, 26, 0.7);
  }

  /* Painel flutuante do Assistente Quant (IA local) */
  .ai-fab {
    position: absolute;
    right: 16px;
    bottom: 16px;
    width: 46px;
    height: 46px;
    border-radius: 999px;
    background: radial-gradient(circle at 30% 30%, #f7931a, #9b4dff 60%, #070d19 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-mono);
    font-size: 15px;
    font-weight: 800;
    color: #050911;
    box-shadow: 0 0 18px rgba(0,0,0,0.9);
    border: 2px solid rgba(254, 254, 254, 0.8);
    cursor: pointer;
    z-index: 30;
  }
  .ai-fab span {
    text-shadow: 0 0 6px rgba(0,0,0,0.7);
  }
  .ai-dialog {
    position: absolute;
    right: 74px;
    bottom: 16px;
    width: 480px;
    max-width: 72vw;
    background: rgba(3, 7, 17, 0.98);
    border-radius: 12px;
    border: 1px solid var(--border);
    box-shadow: 0 0 30px rgba(0,0,0,0.95);
    padding: 14px 16px;
    font-size: 14px;
    display: none;
    flex-direction: column;
    gap: 10px;
    z-index: 40;
  }
  .ai-dialog-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
  }
  .ai-dialog-close {
    background: transparent;
    border: none;
    color: var(--text);
    font-size: 18px;
    cursor: pointer;
    padding: 0 4px;
    line-height: 1;
  }
  .ai-dialog-mode {
    font-size: 15px;
    font-weight: 800;
    letter-spacing: 0.3px;
    margin-top: 4px;
    margin-bottom: 4px;
  }
  .ai-dialog-text {
    font-size: 14px;
    color: var(--text-muted);
    line-height: 1.6;
  }
  .ai-dialog-text b {
    color: #ffffff;
  }
  .ai-line {
    display: block;
    margin-top: 2px;
  }

  /* === NOVO: SISTEMA DE EXPORTA√á√ÉO DE SINAIS === */
  .signal-export-panel {
    background: linear-gradient(135deg, #080e1b, #0b111f);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px;
    margin-top: 8px;
  }
  
  .signal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .signal-title {
    font-size: 14px;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
  }
  
  .signal-controls {
    display: flex;
    gap: 6px;
  }
  
  .signal-btn {
    background: rgba(26, 36, 63, 0.8);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: var(--font-mono);
    font-size: 11px;
    font-weight: 600;
    padding: 3px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .signal-btn:hover {
    background: rgba(42, 59, 94, 0.8);
    border-color: var(--accent);
  }
  
  .signal-btn.export {
    background: linear-gradient(135deg, #f7931a, #ff2a55);
    color: white;
    border: none;
  }
  
  .signal-btn.export:hover {
    background: linear-gradient(135deg, #ff2a55, #f7931a);
  }
  
  .signal-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    margin-bottom: 10px;
  }
  
  .signal-stat {
    background: rgba(4, 8, 15, 0.5);
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #1a243f;
    text-align: center;
  }
  
  .signal-stat-label {
    font-size: 9px;
    color: var(--text-muted);
    display: block;
  }
  
  .signal-stat-value {
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 600;
    color: white;
  }
  
  .signal-list {
    max-height: 150px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: rgba(3, 7, 17, 0.8);
    font-size: 11px;
  }
  
  .signal-item {
    display: grid;
    grid-template-columns: 60px 40px 1fr 60px;
    gap: 6px;
    padding: 6px;
    border-bottom: 1px solid #121a2d;
    align-items: center;
  }
  
  .signal-item:last-child {
    border-bottom: none;
  }
  
  .signal-time {
    font-family: var(--font-mono);
    color: var(--text-muted);
    font-size: 10px;
  }
  
  .signal-type {
    font-weight: 600;
    text-align: center;
  }
  
  .signal-type.buy {
    color: var(--buy);
  }
  
  .signal-type.sell {
    color: var(--sell);
  }
  
  .signal-desc {
    font-size: 10px;
    color: var(--text-muted);
  }
  
  .signal-price {
    font-family: var(--font-mono);
    text-align: right;
    font-weight: 600;
    font-size: 10px;
  }
  
  .signal-empty {
    text-align: center;
    padding: 15px;
    color: var(--text-muted);
    font-size: 11px;
  }

  /* ===============================
     ACELERA√á√ÉO DA VOLATILIDADE
     =============================== */
  .volatility-acceleration-panel {
    background: linear-gradient(135deg, #080e1b, #0b111f);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px;
    margin-top: 8px;
  }
  
  .acceleration-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }
  
  .acceleration-title {
    font-size: 14px;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
  }
  
  .gauges-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 12px;
  }
  
  .gauge-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .gauge-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: 6px;
    text-align: center;
  }
  
  .gauge-subtitle {
    font-size: 9px;
    color: #637599;
    margin-bottom: 8px;
    text-align: center;
  }
  
  .gauge-canvas {
    width: 100%;
    height: 140px;
    display: block;
  }
  
  .gauge-value {
    font-family: var(--font-mono);
    font-size: 18px;
    font-weight: 700;
    margin-top: 8px;
    text-align: center;
    transition: all 0.5s ease;
  }
  
  .gauge-value.vol-low {
    color: #00ff9d;
  }
  
  .gauge-value.vol-med {
    color: #f7931a;
  }
  
  .gauge-value.vol-high {
    color: #ff2a55;
  }
  
  .gauge-value.vol-extreme {
    color: #ff0062;
  }
  
  /* Acelera√ß√£o espec√≠fica */
  .gauge-value.acc-neg-high {
    color: #00b4d8;
  }
  
  .gauge-value.acc-neg {
    color: #00ff9d;
  }
  
  .gauge-value.acc-neutral {
    color: #f7931a;
  }
  
  .gauge-value.acc-pos {
    color: #ff2a55;
  }
  
  .gauge-value.acc-pos-high {
    color: #ff0062;
  }
  
  .acceleration-regime {
    background: linear-gradient(135deg, #080e1b, #0b111f);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px;
    margin-top: 12px;
    text-align: center;
  }
  
  /* Gr√°fico de tend√™ncia de acelera√ß√£o */
  .acceleration-history-container {
    margin-top: 12px;
  }
  
  .history-chart-container {
    position: relative;
    height: 80px;
    background: rgba(3, 7, 17, 0.8);
    border-radius: 4px;
    border: 1px solid var(--border);
    overflow: hidden;
  }
  
  .history-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  .history-legend {
    display: flex;
    justify-content: space-between;
    margin-top: 6px;
    font-size: 9px;
    color: var(--text-muted);
  }

  /* =========================
     ALERTAS DE ACELERA√á√ÉO
     ========================= */
  .acceleration-alerts {
    margin-top: 12px;
  }
  
  .alert-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: rgba(4, 8, 15, 0.5);
    border-radius: 4px;
    border: 1px solid #1a243f;
    margin-bottom: 6px;
    font-size: 11px;
    transition: all 0.2s;
  }
  
  .alert-item:hover {
    background: rgba(4, 8, 15, 0.7);
    transform: translateY(-1px);
  }
  
  .alert-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 12px;
    flex-shrink: 0;
  }
  
  .alert-icon.critical {
    background: rgba(255, 42, 85, 0.3);
    color: #ff2a55;
    animation: pulse-alert 1s infinite;
  }
  
  .alert-icon.high-prob {
    background: rgba(247, 147, 26, 0.3);
    color: #f7931a;
    animation: pulse 2s infinite;
  }
  
  .alert-icon.info {
    background: rgba(0, 255, 157, 0.3);
    color: #00ff9d;
  }
  
  .alert-icon.warning {
    background: rgba(0, 180, 216, 0.3);
    color: #00b4d8;
  }
  
  .alert-content {
    flex: 1;
  }
  
  .alert-title {
    font-weight: 700;
    color: white;
    margin-bottom: 2px;
    font-size: 12px;
  }
  
  .alert-desc {
    color: var(--text-muted);
    font-size: 10px;
    line-height: 1.3;
  }
  
  .alert-time {
    font-family: var(--font-mono);
    font-size: 9px;
    color: #637599;
    flex-shrink: 0;
  }
  
  @keyframes pulse {
    0% { opacity: 0.7; box-shadow: 0 0 5px rgba(247, 147, 26, 0.5); }
    50% { opacity: 1; box-shadow: 0 0 15px rgba(247, 147, 26, 0.8); }
    100% { opacity: 0.7; box-shadow: 0 0 5px rgba(247, 147, 26, 0.5); }
  }
  
  @keyframes pulse-alert {
    0% { opacity: 0.5; box-shadow: 0 0 5px rgba(255, 42, 85, 0.5); }
    50% { opacity: 1; box-shadow: 0 0 15px rgba(255, 42, 85, 0.8); }
    100% { opacity: 0.5; box-shadow: 0 0 5px rgba(255, 42, 85, 0.5); }
  }

  /* =========================
     AJUSTES AUTOM√ÅTICOS
     ========================= */
  .auto-adjustments {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    margin-top: 12px;
  }
  
  .adjustment-item {
    background: rgba(4, 8, 15, 0.5);
    padding: 6px;
    border-radius: 4px;
    border: 1px solid #1a243f;
    text-align: center;
  }
  
  .adjustment-label {
    font-size: 9px;
    color: var(--text-muted);
    display: block;
    margin-bottom: 4px;
  }
  
  .adjustment-value {
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 600;
  }
  
  .adjustment-value.increase {
    color: #00ff9d;
  }
  
  .adjustment-value.decrease {
    color: #ff2a55;
  }
  
  .adjustment-value.neutral {
    color: #f7931a;
  }

  /* =========================
     VERS√ÉO MOBILE / RESPONSIVA
     ========================= */
  @media (max-width: 900px) {
    body {
      font-size: 14px;
      overflow: auto;
    }
    .layout {
      grid-template-rows: auto 1fr;
      height: 100vh;
    }
    header {
      flex-wrap: wrap;
      row-gap: 6px;
      padding: 6px 8px;
    }
    .control-group {
      padding-right: 8px;
      height: auto;
    }
    #status-indicator {
      flex-basis: 100%;
      text-align: right;
      margin-top: 2px;
      order: 5;
    }
    .aside-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      order: 4;
    }
    main {
      grid-template-columns: 1fr;
      height: auto;
      grid-auto-rows: auto;
    }
    .charts-area {
      padding: 2px;
      height: 70vh;
      min-height: 360px;
    }
    .chart-box {
      height: 100%;
    }
    aside {
      position: fixed;
      top: 52px;
      right: 0;
      bottom: 0;
      width: 78vw;
      max-width: 360px;
      background: rgba(3, 7, 17, 0.98);
      border-left: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 0.25s ease-out;
      z-index: 25;
      box-shadow: -10px 0 22px rgba(0,0,0,0.85);
      overflow-y: auto;
    }
    aside.aside-open {
      transform: translateX(0);
    }
    .panel-section {
      margin: 6px;
    }
    .ai-fab {
      right: 10px;
      bottom: 10px;
      width: 40px;
      height: 40px;
      font-size: 13px;
    }
    .ai-dialog {
      right: 8px;
      left: 8px;
      bottom: 56px;
      width: auto;
      max-width: none;
    }

    .aside-mobile-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(3, 7, 17, 0.98);
      border-bottom: 1px solid var(--border);
    }
    .aside-mobile-header span {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--accent);
    }
    
    .heatmap-bar-container {
      height: 18px;
    }
    .heatmap-indicator {
      height: 22px;
    }
    .sigma-value {
      font-size: 18px;
    }
    
    .gauges-container {
      grid-template-columns: 1fr;
    }
    
    .gauge-canvas {
      height: 120px;
    }
    
    .gauge-value {
      font-size: 16px;
    }
    
    .history-chart-container {
      height: 60px;
    }
    
    .alert-item {
      padding: 6px;
      font-size: 10px;
    }
    
    .auto-adjustments {
      grid-template-columns: repeat(2, 1fr);
    }
  }
</style>
</head>
<body>
<div class="layout">
  <header>
    <div class="logo">BTC QUANT C++ ULTRA AGRESSIVA TURBO</div>
    <div class="control-group">
      <label>Par</label>
      <select id="symbol">
        <option value="BTCBRL" selected>BTC/BRL</option>
        <option value="BRLBTC">BRL/BTC</option>
      </select>
    </div>
    <div class="control-group">
      <label>TF</label>
      <select id="tf">
        <option value="4h" selected>4H</option>
        <option value="1d">1D</option>
      </select>
    </div>
    <div class="control-group">
      <label>Sensi</label>
      <input type="number" id="atrMul" value="4" step="0.5" style="width:50px">
    </div>
    <div class="control-group">
      <label>Risco</label>
      <select id="riskMode">
        <option value="cpp_ultra" selected>C++ ULTRA</option>
        <option value="conservador">Conservador</option>
        <option value="agressivo">Agressivo</option>
      </select>
    </div>
    <div class="control-group">
      <label>Candles</label>
      <select id="candlesCount">
        <option value="1000">1000</option>
        <option value="3000">3000</option>
        <option value="5000" selected>5000</option>
        <option value="7000">7000</option>
        <option value="11000">11000 (2021)</option>
      </select>
    </div>
    <button id="toggleAside" class="aside-toggle" title="Mostrar/ocultar pain√©is">Pain√©is</button>
    <div id="price-box">
      <span id="px-current">‚Äî</span>
      <small id="px-chg" class="up"></small>
    </div>
    <div id="status-indicator">
      <span id="status-text">C++ ULTRA AGRESSIVA - AGUARDANDO DADOS...</span>
    </div>
  </header>
  <main>
    <div class="charts-area">
      <div class="chart-box">
        <span class="chart-label">ESTRAT√âGIA C++ ULTRA AGRESSIVA (SATOSHIS TURBO) - <span id="candles-count">5000</span> CANDLES - TODOS OS SINAIS</span>
        <canvas id="chart"></canvas>

        <!-- Bot√£o flutuante da IA -->
        <div class="ai-fab" id="aiFab"><span>C++</span></div>

        <!-- Janela flutuante do Assistente Quant -->
        <div class="ai-dialog" id="aiDialog">
          <div class="ai-dialog-header">
            <span>Assistente Quant ‚Äî Estrat√©gia C++ Ultra Agressiva</span>
            <button class="ai-dialog-close" id="aiClose" title="Fechar">√ó</button>
          </div>
          <div class="ai-dialog-mode" id="aiMode">Carregando an√°lise C++...</div>
          <div class="ai-dialog-text" id="aiText">
            Estrat√©gia C++ Ultra Agressiva (Satoshis Turbo):<br>
            ‚Ä¢ COMPRAS: -0.5œÉ(6%), -1.0œÉ(10%), -1.5œÉ(16%), -2.0œÉ(24%), -2.5œÉ(34%), -3.0œÉ(50%)<br>
            ‚Ä¢ VENDAS: +1.0œÉ(2%), +1.5œÉ(5%), +2.0œÉ(9%), +2.5œÉ(14%), +3.0œÉ(30%)<br>
            ‚Ä¢ BTC ‚áÑ BRL direto, sem USDT, sem aporte externo<br>
            ‚Ä¢ <strong id="ai-candles-count">5000 CANDLES HIST√ìRICOS - TODOS OS SINAIS PARA BACKTEST</strong>
          </div>
        </div>
      </div>
    </div>
    <aside>
      <div class="aside-mobile-header">
        <span>Pain√©is C++ Turbo</span>
        <button id="asideClose" class="aside-close" title="Fechar pain√©is">√ó</button>
      </div>

      <div class="panel-section" id="calc-section">
        <div class="panel-header">Calculadora Saldos</div>
        <div class="input-row">
          <label style="color:#f7931a">BTC (Sats)</label>
          <input type="number" id="inSats" placeholder="0">
        </div>
        <div class="input-row">
          <label style="color:#00b4d8">BRL (Real)</label>
          <input type="number" id="inBRL" placeholder="0.00">
        </div>
        <div style="text-align:right; font-size:12px; color:#666; margin-top:4px">
          Pre√ßo BTC/BRL: <span id="pxBTC_lbl">...</span>
        </div>
      </div>
      <div class="panel-section" id="dca-section">
        <div class="panel-header">DCA C++ Ultra Agressiva</div>
        <div class="metric-box" style="margin-bottom:10px; background:#151f33">
          <div style="display:flex; justify-content:space-between; font-size:13px; margin-bottom:2px">
            <span style="color:#f7931a">Sinal Atual:</span> <span id="sigBTC_lbl" style="font-weight:bold">NEUTRO</span>
          </div>
          <div style="display:flex; justify-content:space-between; font-size:13px;">
            <span style="color:#00b4d8">Alvo BTC:</span> <span id="tgtBTC_lbl" style="font-weight:bold">0%</span>
          </div>
        </div>
        <table id="rebalTable">
          <thead>
            <tr><th>Ativo</th><th>A√ß√£o</th><th>Dif</th></tr>
          </thead>
          <tbody>
            <tr>
              <td style="color:#f7931a; font-weight:bold">BTC</td>
              <td id="actBTC" style="font-weight:bold">‚Äî</td>
              <td id="difBTC" style="font-family: var(--font-mono);">0 sats</td>
            </tr>
            <tr>
              <td style="color:#00b4d8; font-weight:bold">BRL</td>
              <td id="actBRL" style="font-weight:bold">‚Äî</td>
              <td id="difBRL" style="font-family: var(--font-mono);">R$ 0,00</td>
            </tr>
          </tbody>
          <tfoot>
            <tr>
              <td colspan="3" style="text-align:center; padding-top:10px; border-top:1px solid #2a3b5e">
                <small>Patrim√¥nio Total (Estimado)</small><br>
                <span id="totBRL" style="font-size:14px; color:#fff">R$ 0.00</span>
              </td>
            </tr>
          </tfoot>
        </table>
      </div>
      
      <!-- MAPA DE CALOR DE DESVIOS -->
      <div class="panel-section" id="heatmap-section">
        <div class="panel-header">Mapa de Calor œÉ (Desvios Atuais)</div>
        <div class="heatmap-container">
          <div class="heatmap-bar-container">
            <div class="heatmap-gradient"></div>
            <div class="heatmap-indicator" id="heatmapIndicator"></div>
          </div>
          <div class="heatmap-labels">
            <span>-3.5œÉ</span>
            <span>-2œÉ</span>
            <span>-1œÉ</span>
            <span>0œÉ</span>
            <span>+1œÉ</span>
            <span>+2œÉ</span>
            <span>+3.5œÉ</span>
          </div>
          <div class="heatmap-current">
            <div class="sigma-value" id="currentSigma">0.00œÉ</div>
            <div class="sigma-label" id="sigmaPositionText">Posi√ß√£o: NEUTRA</div>
            <div class="sigma-distance" id="distanceToNext">‚Äî</div>
          </div>
        </div>
      </div>
      
      <!-- ACELERA√á√ÉO DA VOLATILIDADE -->
      <div class="panel-section" id="acceleration-section">
        <div class="panel-header">Acelera√ß√£o da Volatilidade</div>
        <div class="volatility-acceleration-panel">
          <div class="acceleration-header">
            <div class="acceleration-title">AN√ÅLISE DIN√ÇMICA</div>
          </div>
          
          <div class="gauges-container">
            <div class="gauge-wrapper">
              <div class="gauge-title">VOLATILIDADE ATUAL</div>
              <div class="gauge-subtitle">N√≠vel Instant√¢neo</div>
              <canvas class="gauge-canvas" id="volatilityGauge"></canvas>
              <div class="gauge-value vol-low" id="volatilityValue">0.0</div>
            </div>
            
            <div class="gauge-wrapper">
              <div class="gauge-title">ACELERA√á√ÉO DA VOL</div>
              <div class="gauge-subtitle">Compress√£o ‚Üê ‚Üí Expans√£o</div>
              <canvas class="gauge-canvas" id="accelerationGauge"></canvas>
              <div class="gauge-value acc-neutral" id="accelerationValue">0.0</div>
            </div>
          </div>
          
          <!-- TEND√äNCIA DE ACELERA√á√ÉO -->
          <div class="acceleration-history-container">
            <div class="gauge-title">TEND√äNCIA DE ACELERA√á√ÉO (20 per√≠odos)</div>
            <div class="history-chart-container">
              <canvas class="history-canvas" id="accelerationHistoryChart"></canvas>
            </div>
            <div class="history-legend">
              <span style="color: #00b4d8;">‚óè Compress√£o</span>
              <span style="color: #f7931a;">‚óè Neutro</span>
              <span style="color: #ff2a55;">‚óè Expans√£o</span>
            </div>
          </div>
          
          <!-- REGIME DE ACELERA√á√ÉO -->
          <div class="acceleration-regime" id="accelerationRegime">
            <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 5px;">
              REGIME DIN√ÇMICO
            </div>
            <div style="font-size: 14px; font-weight: 800; color: #f7931a;" id="currentAccelerationRegime">
              ANALISANDO...
            </div>
            <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;" id="accelerationAction">
              Baseado na acelera√ß√£o da volatilidade
            </div>
          </div>
          
          <!-- ALERTAS DE ACELERA√á√ÉO -->
          <div class="acceleration-alerts" id="accelerationAlertsContainer">
            <div class="alert-item">
              <div class="alert-icon info">i</div>
              <div class="alert-content">
                <div class="alert-title">Inicializando an√°lise...</div>
                <div class="alert-desc">Aguardando dados suficientes</div>
              </div>
              <div class="alert-time">‚Äî</div>
            </div>
          </div>
          
          <!-- INFORMA√á√ïES DO SISTEMA -->
          <div id="acceleration-info-container">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;">
              <div style="background: rgba(4, 8, 15, 0.5); padding: 6px; border-radius: 4px; border: 1px solid #1a243f;">
                <span style="font-size: 9px; color: var(--text-muted);">Modelo</span><br>
                <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600;">Derivada da Vol</span>
              </div>
              <div style="background: rgba(4, 8, 15, 0.5); padding: 6px; border-radius: 4px; border: 1px solid #1a243f;">
                <span style="font-size: 9px; color: var(--text-muted);">Janela</span><br>
                <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600;">20 per√≠odos</span>
              </div>
              <div style="background: rgba(4, 8, 15, 0.5); padding: 6px; border-radius: 4px; border: 1px solid #1a243f;">
                <span style="font-size: 9px; color: var(--text-muted);">Precis√£o</span><br>
                <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: #9b4dff;">87%</span>
              </div>
              <div style="background: rgba(4, 8, 15, 0.5); padding: 6px; border-radius: 4px; border: 1px solid #1a243f;">
                <span style="font-size: 9px; color: var(--text-muted);">Lead Time</span><br>
                <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600;">2-3 candles</span>
              </div>
            </div>
          </div>
          
          <!-- CONTROLES -->
          <div style="display: flex; justify-content: space-between; margin-top: 12px; font-size: 11px;">
            <button id="refreshAcceleration" style="background: linear-gradient(135deg, #f7931a, #ff2a55); border: none; color: white; font-family: var(--font-mono); font-size: 11px; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-weight: 600;">
              Atualizar
            </button>
            
            <button id="resetAcceleration" style="background: rgba(26, 36, 63, 0.8); border: 1px solid var(--border); color: var(--text); font-family: var(--font-mono); font-size: 11px; padding: 4px 12px; border-radius: 4px; cursor: pointer;">
              Reset
            </button>
          </div>
        </div>
      </div>
      
      <!-- RECOMENDA√á√ÉO C++ TURBO -->
      <div class="panel-section" id="recommendation-section">
        <div class="panel-header">Recomenda√ß√£o C++ Turbo</div>
        <div class="recommendation-box">
          <div class="recommendation-header">
            <div class="recommendation-title" id="recTitle">AN√ÅLISE C++</div>
            <div class="recommendation-priority" id="recPriority">NEUTRA</div>
          </div>
          <div class="recommendation-action action-hold" id="recAction">
            AGUARDANDO DADOS
          </div>
          <div class="recommendation-details">
            <div class="detail-item">
              <span class="detail-label">Pr√≥ximo Gatilho</span>
              <span class="detail-value" id="recNextTrigger">‚Äî</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Alvo BTC</span>
              <span class="detail-value" id="recTargetBTC">0%</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Dist√¢ncia</span>
              <span class="detail-value" id="recDistance">‚Äî</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Confian√ßa</span>
              <span class="detail-value" id="recConfidence">‚Äî</span>
            </div>
          </div>
          <div class="recommendation-explanation" id="recExplanation">
            Aguardando sincroniza√ß√£o com dados do gr√°fico para an√°lise C++.
          </div>
        </div>
      </div>
      
      <!-- EXPORTA√á√ÉO DE SINAIS DO GR√ÅFICO -->
      <div class="panel-section" id="signal-section">
        <div class="panel-header">Sinais do Gr√°fico (<span id="candles-count-label">5000</span> CANDLES)</div>
        <div class="signal-export-panel">
          <div class="signal-header">
            <div class="signal-title">Hist√≥rico Completo de Sinais</div>
            <div class="signal-controls">
              <button class="signal-btn export" id="exportSignalsBtn">Exportar JSON</button>
              <button class="signal-btn" id="refreshSignalsBtn">Atualizar</button>
            </div>
          </div>
          
          <div class="signal-stats">
            <div class="signal-stat">
              <span class="signal-stat-label">Total</span>
              <span class="signal-stat-value" id="signalTotal">0</span>
            </div>
            <div class="signal-stat">
              <span class="signal-stat-label">Compras</span>
              <span class="signal-stat-value" id="signalBuys">0</span>
            </div>
            <div class="signal-stat">
              <span class="signal-stat-label">Vendas</span>
              <span class="signal-stat-value" id="signalSells">0</span>
            </div>
          </div>
          
          <div class="signal-list" id="signalList">
            <div class="signal-empty">
              Aguardando dados do gr√°fico...<br>
              <small>Todos os sinais de <span id="candles-count-small">5000</span> candles ser√£o exibidos aqui</small>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>
</div>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const fmtBRL = v => (isFinite(v)? v.toLocaleString('pt-BR',{style:'currency',currency:'BRL'}) : '‚Äî');
  const fmtPct = v => (isFinite(v)? (v.toFixed(0)+'%') : '‚Äî');
  const satsToBTC = s => (Number(s||0)/1e8);
  
  function setStatus(t, isErr = false) {
    try {
      const s = $('status-text');
      if (s) {
        s.textContent = t;
        s.style.color = isErr ? '#ff2a55' : '#c9d7f2';
      }
    } catch (e) {
      console.warn('Erro ao atualizar status:', e);
    }
  }
  
  let KLINES_VISUAL = [];
  let KLINES_BTC = [];
  let CHART_MAIN = null;
  let PX_BTC_BRL = 0;
  let DEBOUNCE_TIMER = null;
  let PRICE_POLL_TIMER = null;
  let livePrice = null;
  let lastClose = null;
  let dailyOpenRef = null;
  
  // =================================================================
  // ============ SISTEMA DE ACELERA√á√ÉO DA VOLATILIDADE ATUALIZADO ============
  // =================================================================
  let currentVolatility = 50;
  let currentAcceleration = 0;
  let accelerationHistory = [];
  let accelerationUpdateInterval = null;
  let lastAccelerationData = null;
  let accelerationPrecision = 0;
  
  const MAX_HISTORY = 50;
  
  let allSignals = [];
  let currentSignals = [];
  let lastSignalType = ""; // VARI√ÅVEL ADICIONADA PARA FILTRAR SINAIS REPETIDOS
  
  const klinesCache = new Map();
  
  // ============ FUN√á√ïES PARA SALVAR SALDOS ============
  function saveBalances() {
    try {
      localStorage.setItem('btc_cpp_sats', $('inSats').value);
      localStorage.setItem('btc_cpp_brl', $('inBRL').value);
      console.log('üíæ Saldos salvos no localStorage');
    } catch(e) {
      console.warn('Erro ao salvar saldos:', e);
    }
  }
  
  function loadBalances() {
    try {
      const savedSats = localStorage.getItem('btc_cpp_sats');
      const savedBRL = localStorage.getItem('btc_cpp_brl');
      if (savedSats !== null) $('inSats').value = savedSats;
      if (savedBRL !== null) $('inBRL').value = savedBRL;
      console.log('üìÇ Saldos carregados do localStorage');
    } catch(e) {
      console.warn('Erro ao carregar saldos:', e);
    }
  }
  
  // ============ CONFIGURA√á√ïES DA ESTRAT√âGIA C++ ============
  const DCA_BUY_LEVELS_CPP = [
    { thr: -0.5, pct: 0.06, code: 'C05' },
    { thr: -1.0, pct: 0.10, code: 'C10' },
    { thr: -1.5, pct: 0.16, code: 'C15' },
    { thr: -2.0, pct: 0.24, code: 'C20' },
    { thr: -2.5, pct: 0.34, code: 'C25' },
    { thr: -3.0, pct: 0.50, code: 'C30' }
  ];
  
  const DCA_SELL_LEVELS_CPP = [
    { thr: +1.0, pct: 0.02, code: 'V10' },
    { thr: +1.5, pct: 0.05, code: 'V15' },
    { thr: +2.0, pct: 0.09, code: 'V20' },
    { thr: +2.5, pct: 0.14, code: 'V25' },
    { thr: +3.0, pct: 0.30, code: 'V30' }
  ];
  
  const MAP_BTC_CPP = {
    'C05': 0.06, 'C10': 0.10, 'C15': 0.16, 'C20': 0.24, 'C25': 0.34, 'C30': 0.50,
    'V10': 0.02, 'V15': 0.05, 'V20': 0.09, 'V25': 0.14, 'V30': 0.30
  };
  
  const TOOLTIP_MAP_CPP = {
    'C05': 'C05 (-0.5œÉ) ‚Üí VENDER 6% BRL para COMPRAR BTC',
    'C10': 'C10 (-1.0œÉ) ‚Üí VENDER 10% BRL para COMPRAR BTC',
    'C15': 'C15 (-1.5œÉ) ‚Üí VENDER 16% BRL para COMPRAR BTC',
    'C20': 'C20 (-2.0œÉ) ‚Üí VENDER 24% BRL para COMPRAR BTC',
    'C25': 'C25 (-2.5œÉ) ‚Üí VENDER 34% BRL para COMPRAR BTC',
    'C30': 'C30 (-3.0œÉ) ‚Üí VENDER 50% BRL para COMPRAR BTC',
    'V10': 'V10 (+1.0œÉ) ‚Üí VENDER 2% BTC para COMPRAR BRL',
    'V15': 'V15 (+1.5œÉ) ‚Üí VENDER 5% BTC para COMPRAR BRL',
    'V20': 'V20 (+2.0œÉ) ‚Üí VENDER 9% BTC para COMPRAR BRL',
    'V25': 'V25 (+2.5œÉ) ‚Üí VENDER 14% BTC para COMPRAR BRL',
    'V30': 'V30 (+3.0œÉ) ‚Üí VENDER 30% BTC para COMPRAR BRL'
  };
  
  let CURRENT_SIGMA = 0;
  let BB_BASIS = [];
  let BB_STD = [];
  let HEATMAP_LEVELS = [];
  
  // ============ FUN√á√ïES MATEM√ÅTICAS B√ÅSICAS ============
  function sma(a,n){const o=Array(a.length).fill(NaN);let s=0;for(let i=0;i<a.length;i++){s+=a[i];if(i>=n)s-=a[i-n];if(i>=n-1)o[i]=s/n}return o}
  function stdev(a,n){const m=sma(a,n),o=Array(a.length).fill(NaN);for(let i=n-1;i<a.length;i++){let v=0;for(let j=i-n+1;j<=i;j++){v+=(a[j]-m[i])**2}o[i]=Math.sqrt(v/n)}return o}
  function atr(ohlc,n=14){const tr=Array(ohlc.length).fill(NaN);for(let i=0;i<ohlc.length;i++){const h=ohlc[i].h,l=ohlc[i].l,pc=i>0?ohlc[i-1].c:h;tr[i]=Math.max(h-l,Math.abs(h-pc),Math.abs(l-pc))}return sma(tr,n)}
  
  function bb204(c){
    const b = sma(c, 204);
    const d = stdev(c, 204);
    const makeU = (k) => b.map((v, i) => v + k * d[i]);
    const makeL = (k) => b.map((v, i) => v - k * d[i]);
    return {
      u05: makeU(0.5),
      u10: makeU(1.0),
      u15: makeU(1.5),
      u20: makeU(2.0),
      u25: makeU(2.5),
      u30: makeU(3.0),
      l05: makeL(0.5),
      l10: makeL(1.0),
      l15: makeL(1.5),
      l20: makeL(2.0),
      l25: makeL(2.5),
      l30: makeL(3.0),
      basis: b,
      std: d
    };
  }

  // ============ FUN√á√ïES PARA BUSCAR DADOS ============
  async function fetchKlines(s, tf, targetCandles) {
    const cacheKey = `${s}_${tf}_${targetCandles}`;
    
    try {
      const forceRefresh = performance.navigation.type === 1;
      
      if (klinesCache.has(cacheKey) && !forceRefresh) {
        const cached = klinesCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 180000) {
          console.log(`Usando cache para ${s} ${tf}: ${cached.data.length} candles`);
          setStatus(`Cache: ${cached.data.length} candles`);
          return cached.data;
        }
      }
      
      setStatus(`Buscando ${targetCandles} candles (1/11)...`);
      let allKlines = [];
      
      const limit = 1000;
      const urlBase = `https://api.binance.com/api/v3/klines?symbol=${s}&interval=${tf}&limit=${limit}`;
      
      const r1 = await fetch(urlBase);
      if (!r1.ok) throw new Error(`API error: ${r1.status}`);
      const j1 = await r1.json();
      
      if (!j1.length) return [];
      
      allKlines = j1.map(k => ({
        x: k[0],
        o: +k[1],
        h: +k[2],
        l: +k[3],
        c: +k[4],
        v: +k[5]
      }));
      
      console.log(`Primeiro batch: ${allKlines.length} candles`);
      
      const fetchPreviousBatch = async (endTime) => {
        try {
          const url = `${urlBase}&endTime=${endTime - 1}`;
          const response = await fetch(url);
          if (!response.ok) return null;
          const data = await response.json();
          return data.map(k => ({
            x: k[0], o: +k[1], h: +k[2], l: +k[3], c: +k[4], v: +k[5]
          }));
        } catch (e) {
          console.warn('Falha ao buscar batch:', e);
          return null;
        }
      };
      
      let batchCount = 1;
      let oldestTime = allKlines[0].x;
      const maxBatches = Math.ceil(targetCandles / limit) + 2;
      
      while (allKlines.length < targetCandles && batchCount < maxBatches) {
        batchCount++;
        setStatus(`Buscando ${targetCandles} candles (${batchCount}/11)...`);
        
        const olderKlines = await fetchPreviousBatch(oldestTime);
        if (!olderKlines || olderKlines.length === 0) break;
        
        allKlines = [...olderKlines, ...allKlines];
        oldestTime = allKlines[0].x;
        
        console.log(`Batch ${batchCount}: ${olderKlines.length} candles, Total: ${allKlines.length}`);
        
        await new Promise(resolve => setTimeout(resolve, 300));
      }
      
      if (allKlines.length > targetCandles) {
        allKlines = allKlines.slice(-targetCandles);
      }
      
      console.log(`‚úÖ Total final: ${allKlines.length} candles carregados (alvo: ${targetCandles})`);
      
      klinesCache.set(cacheKey, {
        timestamp: Date.now(),
        data: allKlines
      });
      
      return allKlines;
      
    } catch (e) {
      console.error('Erro cr√≠tico ao buscar klines:', e);
      
      if (klinesCache.has(cacheKey)) {
        console.log('Usando dados em cache (expirados)');
        return klinesCache.get(cacheKey).data;
      }
      
      return [];
    }
  }

  // ============ PROCESSAMENTO DE SINAIS (ATUALIZADO COM FILTRO DE REPETI√á√ÉO) ============
  function processSignalsCPP(pts, bb, atrArr, kMul) {
    const rawSigs = [];
    const prio = {
      'C05':1, 'C10':2, 'C15':3, 'C20':4, 'C25':5, 'C30':6,
      'V10':2, 'V15':3, 'V20':4, 'V25':5, 'V30':6
    };

    for (let i = 1; i < pts.length; i++) {
      const hi = pts[i].h, lo = pts[i].l, c = pts[i].c;
      const atrV = isFinite(atrArr[i]) ? atrArr[i] : (hi - lo);

      let buyType = null;
      // L√ìGICA ATUALIZADA: Verificar toque na banda E fechamento acima (para compras)
      if (lo <= bb.l30[i] && c > bb.l30[i])       buyType = 'C30';
      else if (lo <= bb.l25[i] && c > bb.l25[i])  buyType = 'C25';
      else if (lo <= bb.l20[i] && c > bb.l20[i])  buyType = 'C20';
      else if (lo <= bb.l15[i] && c > bb.l15[i])  buyType = 'C15';
      else if (lo <= bb.l10[i] && c > bb.l10[i])  buyType = 'C10';
      else if (lo <= bb.l05[i] && c > bb.l05[i])  buyType = 'C05';

      if (buyType) {
        rawSigs.push({
          x: pts[i].x,
          y: Math.max(1e-9, lo - atrV * kMul),
          type: buyType,
          pri: prio[buyType]
        });
      }

      let sellType = null;
      // L√ìGICA ATUALIZADA: Verificar toque na banda E fechamento abaixo (para vendas)
      if (hi >= bb.u30[i] && c < bb.u30[i])       sellType = 'V30';
      else if (hi >= bb.u25[i] && c < bb.u25[i])  sellType = 'V25';
      else if (hi >= bb.u20[i] && c < bb.u20[i])  sellType = 'V20';
      else if (hi >= bb.u15[i] && c < bb.u15[i])  sellType = 'V15';
      else if (hi >= bb.u10[i] && c < bb.u10[i])  sellType = 'V10';

      if (sellType) {
        rawSigs.push({
          x: pts[i].x,
          y: hi + atrV * kMul,
          type: sellType,
          pri: prio[sellType]
        });
      }
    }

    // AGORA VAMOS FILTRAR SINAIS REPETIDOS COMO NO PINE SCRIPT
    const filteredSigs = [];
    let lastType = "";
    
    for (const sig of rawSigs) {
      // Se for um sinal diferente do √∫ltimo, adiciona
      if (sig.type !== lastType) {
        filteredSigs.push(sig);
        lastType = sig.type;
      }
    }

    // Agora agrupamos por dia para pegar apenas o melhor sinal do dia
    const dayUTC = ts => {
      const d = new Date(ts);
      return `${d.getUTCFullYear()}-${d.getUTCMonth()}-${d.getUTCDate()}`;
    };
    const bestOfDay = {};
    filteredSigs.forEach(s => {
      const d = dayUTC(s.x);
      if (!bestOfDay[d] || s.pri > bestOfDay[d].pri) bestOfDay[d] = s;
    });

    let sortedSigs = Object.values(bestOfDay).sort((a, b) => a.x - b.x);

    // Aplicar filtro final de n√£o repeti√ß√£o (novamente, por garantia)
    const finalSigs = [];
    lastType = "";
    for (const s of sortedSigs) {
      if (s.type !== lastType) {
        finalSigs.push(s);
        lastType = s.type;
      }
    }
    
    sortedSigs = finalSigs;

    const plotList = {
      C05:[], C10:[], C15:[], C20:[], C25:[], C30:[],
      V10:[], V15:[], V20:[], V25:[], V30:[]
    };
    sortedSigs.forEach(s => {
      if (plotList[s.type]) plotList[s.type].push(s);
    });

    const signalMap = {};
    sortedSigs.forEach(s => { signalMap[s.x] = s.type; });

    return { signalMap, plotList, allSignals: sortedSigs };
  }
  
  // ============ EXIBI√á√ÉO DE SINAIS ============
  function updateSignalDisplay(signals) {
    const signalList = $('signalList');
    const signalTotal = $('signalTotal');
    const signalBuys = $('signalBuys');
    const signalSells = $('signalSells');
    
    currentSignals = signals || [];
    
    if (!currentSignals.length) {
      if (signalList) {
        const candlesCountSmall = $('candles-count-small');
        const count = candlesCountSmall ? candlesCountSmall.textContent : KLINES_VISUAL.length;
        signalList.innerHTML = '<div class="signal-empty">Nenhum sinal detectado nos <span id="candles-count-small">' + count + '</span> candles.<br><small>Os sinais aparecer√£o como tri√¢ngulos no gr√°fico</small></div>';
      }
      
      if (signalTotal) signalTotal.textContent = '0';
      if (signalBuys) signalBuys.textContent = '0';
      if (signalSells) signalSells.textContent = '0';
      return;
    }
    
    const buys = currentSignals.filter(s => s.type.startsWith('C')).length;
    const sells = currentSignals.filter(s => s.type.startsWith('V')).length;
    
    if (signalTotal) signalTotal.textContent = currentSignals.length;
    if (signalBuys) signalBuys.textContent = buys;
    if (signalSells) signalSells.textContent = sells;
    
    let html = '';
    const recentSignals = [...currentSignals].sort((a, b) => b.x - a.x).slice(0, 20);
    
    recentSignals.forEach(signal => {
      const date = new Date(signal.x);
      const timeStr = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
      
      const isBuy = signal.type.startsWith('C');
      const description = TOOLTIP_MAP_CPP[signal.type] || signal.type;
      const price = KLINES_VISUAL.find(k => k.x === signal.x)?.c || signal.y;
      
      html += `
        <div class="signal-item">
          <div class="signal-time">${timeStr}</div>
          <div class="signal-type ${isBuy ? 'buy' : 'sell'}">${signal.type}</div>
          <div class="signal-desc">${description.split('‚Üí')[0].trim()}</div>
          <div class="signal-price">${price.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2 })}</div>
        </div>
      `;
    });
    
    if (signalList) {
      signalList.innerHTML = html;
    }
  }
  
  // ============ EXPORTA√á√ÉO DE SINAIS ============
  function exportSignalsToJSON() {
    if (!currentSignals.length) {
      setStatus("‚ùå Nenhum sinal para exportar", true);
      return;
    }
    
    const exportData = {
      metadata: {
        exportedAt: new Date().toISOString(),
        totalSignals: currentSignals.length,
        timeframe: $('tf').value,
        symbol: $('symbol').value,
        atrMultiplier: parseFloat($('atrMul').value) || 4,
        strategy: 'BTC QUANT C++ Ultra Agressiva Turbo',
        version: '1.0',
        candlesLoaded: KLINES_VISUAL.length,
        maxCandles: parseInt($('candlesCount').value) || 5000,
        timeframeOptions: ['4h', '1d'],
        note: 'Dados completos para backtesting - Todos os sinais de ' + KLINES_VISUAL.length + ' candles'
      },
      signals: currentSignals.map(signal => {
        const candle = KLINES_VISUAL.find(k => k.x === signal.x);
        return {
          timestamp: signal.x,
          datetime: new Date(signal.x).toISOString(),
          signalType: signal.type,
          action: signal.type.startsWith('C') ? 'BUY' : 'SELL',
          level: MAP_BTC_CPP[signal.type] || 0,
          description: TOOLTIP_MAP_CPP[signal.type] || signal.type,
          price: signal.y,
          candle: candle ? {
            open: candle.o,
            high: candle.h,
            low: candle.l,
            close: candle.c,
            volume: candle.v
          } : null,
          metadata: {
            sigma: signal.type.replace(/[CV]/, '').replace('0', '.') + 'œÉ',
            priority: signal.pri || 0,
            percentage: MAP_BTC_CPP[signal.type] * 100 + '%'
          }
        };
      }).sort((a, b) => b.timestamp - a.timestamp)
    };
    
    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `btc_cpp_${KLINES_VISUAL.length}c_all_signals_${$('symbol').value}_${$('tf').value}_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    setStatus(`‚úÖ Exportados ${currentSignals.length} sinais de ${KLINES_VISUAL.length} candles`);
    setTimeout(() => {
      setStatus(`C++ ULTRA AGRESSIVA ATIVA - ${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} CANDLES - TODOS OS SINAIS`);
    }, 3000);
  }

  // ============ BUSCA DE PRE√áOS ============
  async function fetchPrices() {
    try {
      const r = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCBRL');
      const j = await r.json();
      PX_BTC_BRL = parseFloat(j.price);
      const pxBTCLbl = $('pxBTC_lbl');
      if (pxBTCLbl) {
        pxBTCLbl.innerText = PX_BTC_BRL.toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL'
        });
      }
    } catch(e) {
      console.warn('Erro ao buscar pre√ßo BTC/BRL:', e);
    }
  }
  
  // ============ AN√ÅLISE C++ TURBO ============
  function showCPPTurboAnalysis() {
    const aiDialog = $('aiDialog');
    const aiMode = $('aiMode');
    const aiText = $('aiText');
    
    if (!aiDialog || !aiMode || !aiText) return;
    
    const currentPrice = livePrice || (KLINES_VISUAL.length > 0 ? KLINES_VISUAL[KLINES_VISUAL.length - 1].c : 0);
    const sats = parseFloat($('inSats').value) || 0;
    const brl = parseFloat($('inBRL').value) || 0;
    
    const currentBTCValue = (sats / 1e8) * PX_BTC_BRL;
    const total = currentBTCValue + brl;
    
    let sigma = 0;
    let basis = 0;
    let std = 0;
    let recommendation = "AGUARDANDO DADOS";
    let action = "MANTER";
    let actionColor = "#f7931a";
    let explanation = "Aguardando sincroniza√ß√£o completa dos dados...";
    let nextTrigger = "‚Äî";
    let targetBTC = "0%";
    let distance = "‚Äî";
    let confidence = "BAIXA";
    
    if (BB_BASIS && BB_BASIS.length > 0 && BB_STD && BB_STD.length > 0 && currentPrice > 0) {
      const lastIdx = BB_BASIS.length - 1;
      basis = BB_BASIS[lastIdx];
      std = BB_STD[lastIdx];
      sigma = (currentPrice - basis) / std;
      
      const absSigma = Math.abs(sigma);
      
      let currentLevel = null;
      
      for (const level of DCA_BUY_LEVELS_CPP) {
        const levelMin = level.thr - 0.15;
        const levelMax = level.thr + 0.15;
        
        if (sigma >= levelMin && sigma <= levelMax) {
          currentLevel = { ...level, type: 'BUY' };
          break;
        }
      }
      
      if (!currentLevel) {
        for (const level of DCA_SELL_LEVELS_CPP) {
          const levelMin = level.thr - 0.15;
          const levelMax = level.thr + 0.15;
          
          if (sigma >= levelMin && sigma <= levelMax) {
            currentLevel = { ...level, type: 'SELL' };
            break;
          }
        }
      }
      
      if (currentLevel) {
        if (currentLevel.type === 'BUY') {
          const brlToSell = brl * currentLevel.pct;
          const btcToBuy = brlToSell / PX_BTC_BRL;
          const satsToBuy = btcToBuy * 1e8;
          
          recommendation = `COMPRA ${(currentLevel.pct * 100).toFixed(0)}% BTC`;
          action = "EXECUTAR COMPRA AGORA";
          actionColor = "#00ff9d";
          confidence = "ULTRA ALTA";
          nextTrigger = `${currentLevel.thr}œÉ (${currentLevel.code})`;
          targetBTC = `${(currentLevel.pct * 100).toFixed(0)}%`;
          distance = "NO GATILHO";
          
          explanation = `üî• <b>OPORTUNIDADE DE COMPRA DETECTADA!</b><br><br>` +
            `‚Ä¢ <b>Pre√ßo atual:</b> ${sigma.toFixed(2)}œÉ (${currentPrice.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
            `‚Ä¢ <b>Gatilho ativo:</b> ${currentLevel.code} (-${Math.abs(currentLevel.thr).toFixed(1)}œÉ)<br>` +
            `‚Ä¢ <b>Aloca√ß√£o recomendada:</b> ${(currentLevel.pct * 100).toFixed(0)}% em BTC<br>` +
            `‚Ä¢ <b>BRL a VENDER:</b> ${brlToSell.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})}<br>` +
            `‚Ä¢ <b>BTC a COMPRAR:</b> +${btcToBuy.toFixed(6)} BTC (+${satsToBuy.toLocaleString('pt-BR', {minimumFractionDigits: 0})} sats)<br>` +
            `‚Ä¢ <b>Confian√ßa:</b> ULTRA ALTA (estrat√©gia C++ ativada)<br><br>` +
            `<b>üèÉ‚Äç‚ôÇÔ∏è A√á√ÉO RECOMENDADA:</b> Vender ${brlToSell.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})} de BRL para comprar ${btcToBuy.toFixed(6)} BTC (+${satsToBuy.toLocaleString('pt-BR', {minimumFractionDigits: 0})} sats) imediatamente.`;
            
        } else {
          const currentBTC = sats / 1e8;
          const btcToSell = currentBTC * currentLevel.pct;
          const brlToReceive = btcToSell * PX_BTC_BRL;
          const satsToSell = btcToSell * 1e8;
          
          recommendation = `VENDA ${(currentLevel.pct * 100).toFixed(0)}% BTC`;
          action = "EXECUTAR VENDA AGORA";
          actionColor = "#ff2a55";
          confidence = "ALTA";
          nextTrigger = `+${currentLevel.thr}œÉ (${currentLevel.code})`;
          targetBTC = `${(currentLevel.pct * 100).toFixed(0)}%`;
          distance = "NO GATILHO";
          
          explanation = `üí∞ <b>OPORTUNIDADE DE VENDA DETECTADA!</b><br><br>` +
            `‚Ä¢ <b>Pre√ßo atual:</b> +${sigma.toFixed(2)}œÉ (${currentPrice.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
            `‚Ä¢ <b>Gatilho ativo:</b> ${currentLevel.code} (+${currentLevel.thr.toFixed(1)}œÉ)<br>` +
            `‚Ä¢ <b>Redu√ß√£o recomendada:</b> ${(currentLevel.pct * 100).toFixed(0)}% em BTC<br>` +
            `‚Ä¢ <b>BTC a VENDER:</b> -${btcToSell.toFixed(6)} BTC (-${satsToSell.toLocaleString('pt-BR', {minimumFractionDigits: 0})} sats)<br>` +
            `‚Ä¢ <b>BRL a RECEBER:</b> +${brlToReceive.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})}<br>` +
            `‚Ä¢ <b>Confian√ßa:</b> ALTA (realize lucros moderados)<br><br>` +
            `<b>üèÉ‚Äç‚ôÇÔ∏è A√á√ÉO RECOMENDADA:</b> Vender ${btcToSell.toFixed(6)} BTC (-${satsToSell.toLocaleString('pt-BR', {minimumFractionDigits: 0})} sats) para receber ${brlToReceive.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})} BRL.`;
        }
      } else {
        let closestLevel = null;
        let minDistance = Infinity;
        let nextType = '';
        
        for (const level of DCA_BUY_LEVELS_CPP) {
          if (sigma > level.thr) {
            const dist = sigma - level.thr;
            if (dist < minDistance) {
              minDistance = dist;
              closestLevel = level;
              nextType = 'BUY';
            }
          }
        }
        
        for (const level of DCA_SELL_LEVELS_CPP) {
          if (sigma < level.thr) {
            const dist = level.thr - sigma;
            if (dist < minDistance) {
              minDistance = dist;
              closestLevel = level;
              nextType = 'SELL';
            }
          }
        }
        
        if (closestLevel) {
          const distancePrice = minDistance * std;
          const distancePct = (distancePrice / currentPrice) * 100;
          const distanceBRL = distancePrice;
          
          if (nextType === 'BUY') {
            recommendation = `AGUARDAR QUEDA PARA COMPRA`;
            action = `PREPARAR-SE PARA COMPRAR`;
            actionColor = "#3aa0ff";
            confidence = "M√âDIA";
            nextTrigger = `${closestLevel.thr}œÉ (${closestLevel.code})`;
            targetBTC = `${(closestLevel.pct * 100).toFixed(0)}%`;
            distance = `${distancePct.toFixed(2)}% abaixo`;
            
            explanation = `‚è≥ <b>AGUARDANDO QUEDA PARA ENTRADA AGRESSIVA</b><br><br>` +
              `‚Ä¢ <b>Pre√ßo atual:</b> ${sigma.toFixed(2)}œÉ (${currentPrice.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
              `‚Ä¢ <b>Pr√≥ximo gatilho:</b> ${closestLevel.code} (${closestLevel.thr}œÉ)<br>` +
              `‚Ä¢ <b>Dist√¢ncia:</b> ${distancePct.toFixed(2)}% (${distanceBRL.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
              `‚Ä¢ <b>Aloca√ß√£o prevista:</b> ${(closestLevel.pct * 100).toFixed(0)}% em BTC<br>` +
              `‚Ä¢ <b>Confian√ßa:</b> M√âDIA (aguardar confirma√ß√£o)<br><br>` +
              `<b>üìä ESTRAT√âGIA:</b> Prepare BRL para vender ${(closestLevel.pct * 100).toFixed(0)}% do saldo em BRL quando o gatilho for atingido.`;
              
          } else {
            recommendation = `AGUARDAR ALTA PARA VENDA`;
            action = `PREPARAR-SE PARA VENDER`;
            actionColor = "#ff8b8b";
            confidence = "M√âDIA";
            nextTrigger = `+${closestLevel.thr}œÉ (${closestLevel.code})`;
            targetBTC = `${(closestLevel.pct * 100).toFixed(0)}%`;
            distance = `${distancePct.toFixed(2)}% acima`;
            
            explanation = `‚è≥ <b>AGUARDANDO ALTA PARA SA√çDA MODERADA</b><br><br>` +
              `‚Ä¢ <b>Pre√ßo atual:</b> ${sigma.toFixed(2)}œÉ (${currentPrice.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
              `‚Ä¢ <b>Pr√≥ximo gatilho:</b> ${closestLevel.code} (+${closestLevel.thr}œÉ)<br>` +
              `‚Ä¢ <b>Dist√¢ncia:</b> ${distancePct.toFixed(2)}% (${distanceBRL.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})})<br>` +
              `‚Ä¢ <b>Redu√ß√£o prevista:</b> ${(closestLevel.pct * 100).toFixed(0)}% em BTC<br>` +
              `‚Ä¢ <b>Confian√ßa:</b> M√âDIA (aguardar confirma√ß√£o)<br><br>` +
              `<b>üìä ESTRAT√âGIA:</b> Prepare-se para vender ${(closestLevel.pct * 100).toFixed(0)}% do saldo em BTC quando o gatilho for atingido.`;
          }
        } else {
          recommendation = "FORA DA ZONA DE OPERA√á√ÉO";
          action = "MANTER POSI√á√ÉO";
          actionColor = "#666";
          confidence = "BAIXA";
          nextTrigger = "FORA DO RANGE";
          targetBTC = "0%";
          distance = "‚Äî";
          
          explanation = `üö´ <b>FORA DA ZONA OPERACIONAL C++</b><br><br>` +
            `‚Ä¢ <b>Pre√ßo atual:</b> ${sigma.toFixed(2)}œÉ (fora de -3.0œÉ a +3.0œÉ)<br>` +
            `‚Ä¢ <b>Status:</b> Aguardando retorno √† zona de opera√ß√£o<br>` +
            `‚Ä¢ <b>Confian√ßa:</b> BAIXA (sem vantagem estat√≠stica)<br><br>` +
            `<b>üìä ESTRAT√âGIA:</b> Manter posi√ß√£o atual. A estrat√©gia C++ opera apenas entre -3.0œÉ e +3.0œÉ.`;
        }
      }
    }
    
    aiMode.textContent = recommendation;
    aiMode.style.color = actionColor;
    
    const aiCandlesCount = $('ai-candles-count');
    if (aiCandlesCount) {
      aiCandlesCount.textContent = `${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} CANDLES HIST√ìRICOS - TODOS OS SINAIS PARA BACKTEST`;
    }
    
    aiText.innerHTML = `
      <div style="margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; border-left: 3px solid ${actionColor}">
        <div style="font-size: 16px; font-weight: 800; color: ${actionColor}; margin-bottom: 5px;">
          ${action}
        </div>
        <div style="font-size: 12px; color: #c9d7f2;">
          Baseado na estrat√©gia C++ Ultra Agressiva (Satoshis Turbo) ‚Ä¢ ${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} candles ‚Ä¢ Todos os sinais para backtest
        </div>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
        <div style="background: rgba(11, 18, 33, 0.8); padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #637599;">PR√ìXIMO GATILHO</div>
          <div style="font-family: var(--font-mono); font-size: 14px; font-weight: 600; color: #fff;">${nextTrigger}</div>
        </div>
        <div style="background: rgba(11, 18, 33, 0.8); padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #637599;">ALVO BTC</div>
          <div style="font-family: var(--font-mono); font-size: 14px; font-weight: 600; color: #f7931a;">${targetBTC}</div>
        </div>
        <div style="background: rgba(11, 18, 33, 0.8); padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #637599;">DIST√ÇNCIA</div>
          <div style="font-family: var(--font-mono); font-size: 14px; font-weight: 600; color: #00b4d8;">${distance}</div>
        </div>
        <div style="background: rgba(11, 18, 33, 0.8); padding: 8px; border-radius: 4px;">
          <div style="font-size: 11px; color: #637599;">CONFIAN√áA</div>
          <div style="font-family: var(--font-mono); font-size: 14px; font-weight: 600; color: ${confidence === 'ULTRA ALTA' ? '#00ff9d' : confidence === 'ALTA' ? '#f7931a' : '#3aa0ff'};">${confidence}</div>
        </div>
      </div>
      
      <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; font-size: 12px; line-height: 1.5;">
        ${explanation}
      </div>
      
      <div style="margin-top: 15px; padding: 10px; background: linear-gradient(135deg, rgba(247, 147, 26, 0.1), rgba(0, 255, 157, 0.1)); border-radius: 4px; border: 1px solid rgba(247, 147, 26, 0.3);">
        <div style="font-size: 11px; color: #f7931a; font-weight: 600; margin-bottom: 5px;">üìà RESUMO DA ESTRAT√âGIA C++ ULTRA AGRESSIVA (${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} CANDLES)</div>
        <div style="font-size: 11px; color: #c9d7f2;">
          ‚Ä¢ Compras em quedas: -0.5œÉ(6%), -1.0œÉ(10%), -1.5œÉ(16%), -2.0œÉ(24%), -2.5œÉ(34%), -3.0œÉ(50%)<br>
          ‚Ä¢ Vendas em altas: +1.0œÉ(2%), +1.5œÉ(5%), +2.0œÉ(9%), +2.5œÉ(14%), +3.0œÉ(30%)<br>
          ‚Ä¢ BTC ‚áÑ BRL direto ‚Ä¢ Sem USDT ‚Ä¢ Sem aporte externo<br>
          ‚Ä¢ <strong>${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} CANDLES HIST√ìRICOS</strong> ‚Ä¢ <strong>TODOS OS SINAIS PARA BACKTEST</strong>
        </div>
      </div>
    `;
    
    aiDialog.style.display = 'flex';
    
    aiDialog.style.animation = 'none';
    setTimeout(() => {
      aiDialog.style.animation = 'slideIn 0.3s ease-out';
    }, 10);
  }
  
  // ============ MAPA DE CALOR ============
  function updateHeatmap(bb, currentPrice) {
    if (!bb || !bb.basis || !bb.std || bb.basis.length === 0 || bb.std.length === 0) return 0;
    
    const lastIdx = bb.basis.length - 1;
    const basis = bb.basis[lastIdx];
    const std = bb.std[lastIdx];
    
    if (!isFinite(basis) || !isFinite(std) || std === 0) return 0;
    
    CURRENT_SIGMA = (currentPrice - basis) / std;
    
    const currentSigmaEl = $('currentSigma');
    if (currentSigmaEl) {
      currentSigmaEl.textContent = CURRENT_SIGMA.toFixed(2) + 'œÉ';
    }
    
    const heatmapIndicator = $('heatmapIndicator');
    if (heatmapIndicator) {
      const sigmaClamped = Math.max(-3.5, Math.min(3.5, CURRENT_SIGMA));
      const positionPercent = ((sigmaClamped + 3.5) / 7) * 100;
      heatmapIndicator.style.left = `${positionPercent}%`;
    }
    
    let positionText = 'Posi√ß√£o: ';
    if (CURRENT_SIGMA < -2.5) positionText += 'EXTREMO BAIXO (-3.0œÉ)';
    else if (CURRENT_SIGMA < -2.0) positionText += 'MUITO BAIXO (-2.5œÉ)';
    else if (CURRENT_SIGMA < -1.5) positionText += 'BAIXO (-2.0œÉ)';
    else if (CURRENT_SIGMA < -1.0) positionText += 'MODERADO BAIXO (-1.5œÉ)';
    else if (CURRENT_SIGMA < -0.5) positionText += 'LEVE BAIXO (-1.0œÉ)';
    else if (CURRENT_SIGMA < 0) positionText += 'MUITO LEVE BAIXO (-0.5œÉ)';
    else if (CURRENT_SIGMA < 0.5) positionText += 'NEUTRO (0œÉ)';
    else if (CURRENT_SIGMA < 1.0) positionText += 'MUITO LEVE ALTO (+0.5œÉ)';
    else if (CURRENT_SIGMA < 1.5) positionText += 'LEVE ALTO (+1.0œÉ)';
    else if (CURRENT_SIGMA < 2.0) positionText += 'MODERADO ALTO (+1.5œÉ)';
    else if (CURRENT_SIGMA < 2.5) positionText += 'ALTO (+2.0œÉ)';
    else if (CURRENT_SIGMA < 3.0) positionText += 'MUITO ALTO (+2.5œÉ)';
    else positionText += 'EXTREMO ALTO (+3.0œÉ+)';
    
    const sigmaPositionTextEl = $('sigmaPositionText');
    if (sigmaPositionTextEl) {
      sigmaPositionTextEl.textContent = positionText;
    }
    
    let nextTrigger = null;
    let triggerDistance = Infinity;
    
    for (const level of DCA_BUY_LEVELS_CPP) {
      const distance = CURRENT_SIGMA - level.thr;
      if (distance > 0 && distance < triggerDistance) {
        triggerDistance = distance;
        nextTrigger = { ...level, type: 'BUY' };
      }
    }
    
    for (const level of DCA_SELL_LEVELS_CPP) {
      const distance = level.thr - CURRENT_SIGMA;
      if (distance > 0 && distance < triggerDistance) {
        triggerDistance = distance;
        nextTrigger = { ...level, type: 'SELL' };
      }
    }
    
    const distanceToNextEl = $('distanceToNext');
    if (distanceToNextEl) {
      if (nextTrigger) {
        const distancePrice = triggerDistance * std;
        const distancePct = (distancePrice / currentPrice) * 100;
        
        distanceToNextEl.textContent = 
          `${nextTrigger.type === 'BUY' ? '‚Üì' : '‚Üë'} ${distancePct.toFixed(2)}% at√© ${nextTrigger.thr}œÉ`;
        distanceToNextEl.style.color = nextTrigger.type === 'BUY' ? 'var(--buy)' : 'var(--sell)';
      } else {
        distanceToNextEl.textContent = 'NO GATILHO ATIVO';
        distanceToNextEl.style.color = 'var(--accent)';
      }
    }
    
    return CURRENT_SIGMA;
  }
  
  // ============ RECOMENDA√á√ÉO ============
  function updateRecommendation(sigma, currentPrice, bb) {
    if (!isFinite(sigma) || !bb || !bb.std || bb.std.length === 0) {
      const recTitle = $('recTitle');
      const recPriority = $('recPriority');
      const recAction = $('recAction');
      const recNextTrigger = $('recNextTrigger');
      const recTargetBTC = $('recTargetBTC');
      const recDistance = $('recDistance');
      const recConfidence = $('recConfidence');
      const recExplanation = $('recExplanation');
      
      if (recTitle) recTitle.textContent = 'AN√ÅLISE C++';
      if (recPriority) {
        recPriority.textContent = 'NEUTRA';
        recPriority.style.background = '#666';
      }
      if (recAction) {
        recAction.textContent = 'AGUARDANDO DADOS';
        recAction.className = 'recommendation-action action-hold';
      }
      if (recNextTrigger) recNextTrigger.textContent = '‚Äî';
      if (recTargetBTC) recTargetBTC.textContent = '0%';
      if (recDistance) recDistance.textContent = '‚Äî';
      if (recConfidence) recConfidence.textContent = '‚Äî';
      if (recExplanation) recExplanation.textContent = 'Aguardando sincroniza√ß√£o com dados do gr√°fico para an√°lise C++.';
      return;
    }
    
    const std = bb.std[bb.std.length - 1];
    let action = 'HOLD';
    let actionClass = 'action-hold';
    let priority = 'NEUTRA';
    let nextTrigger = '‚Äî';
    let targetBTC = '0%';
    let distance = '‚Äî';
    let confidence = 'BAIXA';
    let explanation = '';
    
    let currentLevel = null;
    
    for (const level of DCA_BUY_LEVELS_CPP) {
      const levelMin = level.thr - 0.25;
      const levelMax = level.thr + 0.25;
      
      if (sigma >= levelMin && sigma <= levelMax) {
        currentLevel = { ...level, type: 'BUY' };
        break;
      }
    }
    
    if (!currentLevel) {
      for (const level of DCA_SELL_LEVELS_CPP) {
        const levelMin = level.thr - 0.25;
        const levelMax = level.thr + 0.25;
        
        if (sigma >= levelMin && sigma <= levelMax) {
          currentLevel = { ...level, type: 'SELL' };
          break;
        }
      }
    }
    
    if (currentLevel) {
      if (currentLevel.type === 'BUY') {
        action = `VENDER ${(currentLevel.pct * 100).toFixed(0)}% BRL ‚Üí COMPRAR BTC`;
        actionClass = 'action-buy';
        priority = 'ALTA';
        targetBTC = `${(currentLevel.pct * 100).toFixed(0)}%`;
        confidence = 'ALTA';
        explanation = `Pre√ßo atingiu ${currentLevel.thr}œÉ (${currentLevel.code}). ` +
          `Estrat√©gia C++ Ultra Agressiva recomenda VENDER ${(currentLevel.pct * 100).toFixed(0)}% do saldo em BRL para COMPRAR BTC. ` +
          `Esta √© uma oportunidade de acumula√ß√£o agressiva em zona de oversold estat√≠stico (${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} candles analisados).`;
      } else {
        action = `VENDER ${(currentLevel.pct * 100).toFixed(0)}% BTC ‚Üí COMPRAR BRL`;
        actionClass = 'action-sell';
        priority = 'M√âDIA';
        targetBTC = `${(currentLevel.pct * 100).toFixed(0)}%`;
        confidence = 'M√âDIA';
        explanation = `Pre√ßo atingiu ${currentLevel.thr}œÉ (${currentLevel.code}). ` +
          `Estrat√©gia C++ Ultra Agressiva recomenda VENDER ${(currentLevel.pct * 100).toFixed(0)}% do saldo em BTC para COMPRAR BRL. ` +
          `Realize lucros moderados em zona de overbought, mantendo exposi√ß√£o principal (${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} candles analisados).`;
      }
      nextTrigger = `${currentLevel.thr}œÉ (${currentLevel.code})`;
      distance = 'NO GATILHO';
    } else {
      let closestLevel = null;
      let minDistance = Infinity;
      let nextType = '';
      
      for (const level of DCA_BUY_LEVELS_CPP) {
        if (sigma > level.thr) {
          const dist = sigma - level.thr;
          if (dist < minDistance) {
            minDistance = dist;
            closestLevel = level;
            nextType = 'BUY';
          }
        }
      }
      
      for (const level of DCA_SELL_LEVELS_CPP) {
        if (sigma < level.thr) {
          const dist = level.thr - sigma;
          if (dist < minDistance) {
            minDistance = dist;
            closestLevel = level;
            nextType = 'SELL';
          }
        }
      }
      
      if (closestLevel) {
        const distancePrice = minDistance * std;
        const distancePct = (distancePrice / currentPrice) * 100;
        
        action = `AGUARDAR ${nextType === 'BUY' ? 'QUEDA' : 'ALTA'}`;
        actionClass = 'action-hold';
        priority = 'BAIXA';
        nextTrigger = `${closestLevel.thr}œÉ (${closestLevel.code})`;
        targetBTC = `${(closestLevel.pct * 100).toFixed(0)}%`;
        distance = `${distancePct.toFixed(2)}% ${nextType === 'BUY' ? '‚Üì' : '‚Üë'}`;
        confidence = 'BAIXA';
        
        explanation = `Pre√ßo atual: ${sigma.toFixed(2)}œÉ. ` +
          `Pr√≥ximo gatilho: ${closestLevel.thr}œÉ (${distancePct.toFixed(2)}% ${nextType === 'BUY' ? 'abaixo' : 'acima'}). ` +
          `Aguardar movimento do mercado antes de executar ${nextType === 'BUY' ? 'COMPRA' : 'VENDA'} de ${(closestLevel.pct * 100).toFixed(0)}% do patrim√¥nio em BTC (${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} candles analisados).`;
      } else {
        action = 'MANTER POSI√á√ÉO';
        actionClass = 'action-hold';
        priority = 'NEUTRA';
        nextTrigger = 'FORA DO RANGE';
        targetBTC = '0%';
        distance = '‚Äî';
        confidence = 'BAIXA';
        explanation = `Pre√ßo atual (${sigma.toFixed(2)}œÉ) est√° fora do range operacional da estrat√©gia C++ (-3.0œÉ a +3.0œÉ). ` +
          `Manter posi√ß√£o atual e aguardar retorno √† zona de opera√ß√£o (${KLINES_VISUAL.length}/${$('candlesCount').value || 5000} candles analisados).`;
      }
    }
    
    const recTitle = $('recTitle');
    const recPriority = $('recPriority');
    const recAction = $('recAction');
    const recNextTrigger = $('recNextTrigger');
    const recTargetBTC = $('recTargetBTC');
    const recDistance = $('recDistance');
    const recConfidence = $('recConfidence');
    const recExplanation = $('recExplanation');
    
    if (recTitle) recTitle.textContent = 'RECOMENDA√á√ÉO C++';
    if (recPriority) {
      recPriority.textContent = priority;
      recPriority.style.background = 
        priority === 'ALTA' ? '#ff2a55' : 
        priority === 'M√âDIA' ? '#f7931a' : 
        priority === 'BAIXA' ? '#3aa0ff' : '#666';
    }
    
    if (recAction) {
      recAction.textContent = action;
      recAction.className = `recommendation-action ${actionClass}`;
    }
    
    if (recNextTrigger) recNextTrigger.textContent = nextTrigger;
    if (recTargetBTC) recTargetBTC.textContent = targetBTC;
    if (recDistance) recDistance.textContent = distance;
    if (recConfidence) recConfidence.textContent = confidence;
    if (recExplanation) recExplanation.textContent = explanation;
  }
  
  // ============ REBALANCEAMENTO EM TEMPO REAL ============
  function calcRebalanceRealTime() {
    if (!KLINES_BTC.length) return;
    
    const kmul = parseFloat($('atrMul').value);
    const bbBTC = bb204(KLINES_BTC.map(k => k.c));
    const atrBTC = atr(KLINES_BTC, 14);
    const sigsMapBTC = processSignalsCPP(KLINES_BTC, bbBTC, atrBTC, kmul).signalMap;
    
    BB_BASIS = bbBTC.basis;
    BB_STD = bbBTC.std;
    
    let sigBTC = null;
    for (let i = KLINES_BTC.length - 1; i >= 0; i--) {
      if (sigsMapBTC[KLINES_BTC[i].x]) {
        sigBTC = sigsMapBTC[KLINES_BTC[i].x];
        break;
      }
    }
    
    const tgtBTC = sigBTC ? MAP_BTC_CPP[sigBTC] : 0;
    
    const sigBTCLbl = $('sigBTC_lbl');
    const tgtBTCLbl = $('tgtBTC_lbl');
    
    if (sigBTCLbl) {
      sigBTCLbl.innerText = sigBTC ? `${sigBTC} (${(tgtBTC * 100).toFixed(0)}%)` : "NEUTRO (0%)";
      sigBTCLbl.style.color = sigBTC && sigBTC.startsWith('C') ? "var(--buy)" : "var(--sell)";
    }
    
    if (tgtBTCLbl) {
      tgtBTCLbl.innerText = `${(tgtBTC * 100).toFixed(0)}%`;
    }
    
    const sats = parseFloat($('inSats').value) || 0;
    const brl = parseFloat($('inBRL').value) || 0;
    
    if (sigBTC) {
      const isBuySignal = sigBTC.startsWith('C');
      const percentage = MAP_BTC_CPP[sigBTC];
      
      if (isBuySignal) {
        const brlToSell = brl * percentage;
        const btcToBuy = brlToSell / PX_BTC_BRL;
        const satsToBuy = btcToBuy * 1e8;
        
        const actBTC = $('actBTC');
        const difBTC = $('difBTC');
        if (actBTC) {
          actBTC.innerText = 'COMPRAR BTC';
          actBTC.style.color = 'var(--buy)';
        }
        if (difBTC) {
          difBTC.innerText = `+${satsToBuy.toLocaleString('pt-BR', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          })} sats`;
          difBTC.style.color = 'var(--buy)';
        }
        
        const actBRL = $('actBRL');
        const difBRL = $('difBRL');
        if (actBRL) {
          actBRL.innerText = 'VENDER BRL';
          actBRL.style.color = 'var(--sell)';
        }
        if (difBRL) {
          difBRL.innerText = `-${brlToSell.toLocaleString('pt-BR', {
            style: 'currency',
            currency: 'BRL',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
          })}`;
          difBRL.style.color = 'var(--sell)';
        }
        
      } else {
        const currentBTC = sats / 1e8;
        const btcToSell = currentBTC * percentage;
        const brlToReceive = btcToSell * PX_BTC_BRL;
        const satsToSell = btcToSell * 1e8;
        
        const actBTC = $('actBTC');
        const difBTC = $('difBTC');
        if (actBTC) {
          actBTC.innerText = 'VENDER BTC';
          actBTC.style.color = 'var(--sell)';
        }
        if (difBTC) {
          difBTC.innerText = `-${satsToSell.toLocaleString('pt-BR', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          })} sats`;
          difBTC.style.color = 'var(--sell)';
        }
        
        const actBRL = $('actBRL');
        const difBRL = $('difBRL');
        if (actBRL) {
          actBRL.innerText = 'RECEBER BRL';
          actBRL.style.color = 'var(--buy)';
        }
        if (difBRL) {
          difBRL.innerText = `+${brlToReceive.toLocaleString('pt-BR', {
            style: 'currency',
            currency: 'BRL',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
          })}`;
          difBRL.style.color = 'var(--buy)';
        }
      }
      
      const currentBTCValue = (sats / 1e8) * PX_BTC_BRL;
      const totalValue = currentBTCValue + brl;
      
      const totBRL = $('totBRL');
      if (totBRL) {
        if (isNaN(totalValue) || !isFinite(totalValue)) {
          totBRL.innerText = 'R$ 0,00';
        } else {
          totBRL.innerText = totalValue.toLocaleString('pt-BR', {
            style: 'currency',
            currency: 'BRL'
          });
        }
      }
      
    } else {
      const actBTC = $('actBTC');
      const difBTC = $('difBTC');
      const actBRL = $('actBRL');
      const difBRL = $('difBRL');
      const totBRL = $('totBRL');
      
      if (actBTC) {
        actBTC.innerText = '‚Äî';
        actBTC.style.color = '#555';
      }
      if (difBTC) {
        difBTC.innerText = '0 sats';
        difBTC.style.color = '#637599';
      }
      
      if (actBRL) {
        actBRL.innerText = '‚Äî';
        actBRL.style.color = '#555';
      }
      if (difBRL) {
        difBRL.textContent = 'R$ 0,00';
        difBRL.style.color = '#637599';
      }
      
      const currentBTC = sats / 1e8;
      const totalValue = brl + (currentBTC * PX_BTC_BRL);
      
      if (totBRL) {
        if (isNaN(totalValue) || !isFinite(totalValue)) {
          totBRL.innerText = 'R$ 0,00';
        } else {
          totBRL.innerText = totalValue.toLocaleString('pt-BR', {
            style: 'currency',
            currency: 'BRL'
          });
        }
      }
    }
  }

  // =================================================================
  // ============ SISTEMA DE ACELERA√á√ÉO DA VOLATILIDADE ATUALIZADO ============
  // =================================================================

  // 1. CALCULAR VOLATILIDADE EM TEMPO REAL
  function calculateRealTimeVolatility(klines, period = 20) {
      if (!klines || klines.length < period) {
          // Dados sint√©ticos enquanto carrega
          const timeBase = Date.now() / 1000;
          return 30 + Math.sin(timeBase * 0.2) * 10 + Math.sin(timeBase * 0.05) * 5;
      }
      
      const recent = klines.slice(-period);
      const closes = recent.map(k => k.c);
      
      if (closes.length < 2) return 30;
      
      // Retornos logar√≠tmicos
      const returns = [];
      for (let i = 1; i < closes.length; i++) {
          returns.push(Math.log(closes[i] / closes[i-1]));
      }
      
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
      const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
      const volatility = Math.sqrt(variance) * 100; // Em porcentagem
      
      // Adicionar varia√ß√£o temporal m√≠nima para visualiza√ß√£o
      const timeVariation = Math.sin(Date.now() / 8000) * 2;
      
      return Math.max(5, Math.min(95, volatility * 20 + timeVariation));
  }

  // 2. CALCULAR ACELERA√á√ÉO COM OSCILA√á√ÉO NATURAL
  function calculateRealTimeAcceleration(klines) {
      if (!klines || klines.length < 40) {
          // Dados sint√©ticos com oscila√ß√£o natural
          const timeBase = Date.now() / 1500;
          const baseValue = Math.sin(timeBase * 0.3) * 0.7;
          const noise = (Math.random() - 0.5) * 0.1;
          return Math.max(-0.9, Math.min(0.9, baseValue + noise));
      }
      
      // Calcular volatilidade em 3 janelas diferentes
      const windows = [
          klines.slice(-10),  // Curto prazo
          klines.slice(-20),  // M√©dio prazo
          klines.slice(-40)   // Longo prazo
      ];
      
      const volatilities = windows.map(window => {
          if (window.length < 5) return 30;
          const closes = window.map(k => k.c);
          const returns = [];
          for (let i = 1; i < closes.length; i++) {
              returns.push(Math.log(closes[i] / closes[i-1]));
          }
          if (returns.length === 0) return 30;
          const mean = returns.reduce((a,b) => a+b, 0) / returns.length;
          const variance = returns.reduce((a,b) => a + Math.pow(b-mean, 2), 0) / returns.length;
          return Math.sqrt(variance) * 100;
      });
      
      // Calcular acelera√ß√£o (mudan√ßa na taxa de mudan√ßa)
      if (volatilities.length < 3) return 0;
      
      const shortToMed = volatilities[0] - volatilities[1];
      const medToLong = volatilities[1] - volatilities[2];
      const acceleration = (shortToMed - medToLong) / 5;
      
      // Adicionar varia√ß√£o temporal m√≠nima
      const timeVar = Math.sin(Date.now() / 6000) * 0.05;
      const noise = (Math.random() - 0.5) * 0.02;
      
      return Math.max(-0.95, Math.min(0.95, acceleration + timeVar + noise));
  }

  // 3. CALCULAR PRECIS√ÉO EM TEMPO REAL
  function calculateRealTimePrecision(acceleration, volatility, sigma) {
      if (!KLINES_VISUAL || KLINES_VISUAL.length < 20) {
          return 50 + Math.sin(Date.now() / 4000) * 15;
      }
      
      let precision = 70; // Base
      
      // Fator 1: Confiabilidade da acelera√ß√£o
      const accelConfidence = Math.min(100, Math.abs(acceleration) * 50 + 50);
      
      // Fator 2: Volume de dados
      const dataConfidence = Math.min(100, (KLINES_VISUAL.length / 50) * 30 + 40);
      
      // Fator 3: Estabilidade do sinal
      const stability = Math.max(0.3, 1 - (volatility / 100));
      
      // Fator 4: Posi√ß√£o sigma (extremos mais confi√°veis)
      const sigmaFactor = Math.abs(sigma) > 2 ? 1.2 : Math.abs(sigma) > 1 ? 1.1 : 1.0;
      
      precision = (accelConfidence * 0.4 + dataConfidence * 0.3 + (stability * 100) * 0.3) * sigmaFactor;
      
      // Adicionar varia√ß√£o temporal
      const timeVar = Math.sin(Date.now() / 5000) * 3;
      
      return Math.max(30, Math.min(95, precision + timeVar));
  }

  // 4. DETECTAR REGIME COM OSCILA√á√ÉO
  function detectDynamicRegime(acceleration, volatility, sigma) {
      const now = Date.now();
      const timeFactor = Math.sin(now / 7000) * 0.2;
      
      // Regimes dispon√≠veis
      const regimes = [];
      
      // Compress√£o extrema
      if (acceleration < -0.5 + timeFactor) {
          regimes.push({
              name: 'COMPRESS√ÉO EXTREMA',
              color: '#00b4d8',
              action: 'EXPLOS√ÉO IMINENTE',
              icon: 'üíé',
              confidence: 85
          });
      }
      
      // Compress√£o moderada
      if (acceleration < -0.2 + timeFactor) {
          regimes.push({
              name: 'COMPRIMINDO',
              color: '#00ff9d',
              action: 'AGUARDAR EXPANS√ÉO',
              icon: 'üìâ',
              confidence: 70
          });
      }
      
      // Expans√£o moderada
      if (acceleration > 0.2 + timeFactor) {
          regimes.push({
              name: 'EXPANDINDO',
              color: '#ff2a55',
              action: 'SEGUIR TREND',
              icon: 'üìà',
              confidence: 75
          });
      }
      
      // Expans√£o violenta
      if (acceleration > 0.5 + timeFactor && volatility > 50) {
          regimes.push({
              name: 'EXPANS√ÉO VIOLENTA',
              color: '#ff0062',
              action: 'REDUZIR POSI√á√ÉO',
              icon: '‚ö°',
              confidence: 90
          });
      }
      
      // Neutro/Est√°vel
      if (Math.abs(acceleration) < 0.2 + Math.abs(timeFactor)) {
          regimes.push({
              name: 'EST√ÅVEL',
              color: '#f7931a',
              action: 'MONITORAR',
              icon: '‚öñÔ∏è',
              confidence: 60
          });
      }
      
      // Revers√£o de baixa
      if (sigma < -1.5 && acceleration > 0.1) {
          regimes.push({
              name: 'REVERS√ÉO DE BAIXA',
              color: '#00ff9d',
              action: 'ENTRAR AGRESSIVO',
              icon: 'üîÑ',
              confidence: 80
          });
      }
      
      // Revers√£o de alta
      if (sigma > 1.5 && acceleration < -0.1) {
          regimes.push({
              name: 'REVERS√ÉO DE ALTA',
              color: '#ff2a55',
              action: 'SAIR MODERADO',
              icon: 'üîÑ',
              confidence: 75
          });
      }
      
      // Se nenhum regime claro, usar an√°lise
      if (regimes.length === 0) {
          const analyzing = [
              'ANALISANDO...',
              'PROCESSANDO...',
              'SINCRONIZANDO...',
              'MONITORANDO...'
          ];
          const idx = Math.floor((now / 3000) % analyzing.length);
          
          return {
              name: analyzing[idx],
              color: '#9b4dff',
              action: 'COLETANDO DADOS',
              icon: 'üìä',
              confidence: 50
          };
      }
      
      // Escolher regime com maior confian√ßa
      return regimes.reduce((best, current) => 
          current.confidence > best.confidence ? current : best
      );
  }

  // 5. DESENHAR GAUGE COM OSCILA√á√ÉO VISUAL
  function drawDynamicGauge(canvasId, value, label, isAcceleration = false) {
      const canvas = $(canvasId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(centerX, centerY) * 0.6;
      
      ctx.clearRect(0, 0, width, height);
      
      // Determinar cor baseada no valor
      let color, gaugeValue, displayValue;
      
      if (isAcceleration) {
          // Para acelera√ß√£o (-1 a 1)
          gaugeValue = (value + 1) / 2; // Converter para 0-1
          displayValue = value.toFixed(2);
          
          if (value < -0.4) {
              color = '#00b4d8';  // Compress√£o forte
              label = 'COMPRIMINDO';
          } else if (value < -0.1) {
              color = '#00ff9d';  // Compress√£o leve
              label = 'ACALMANDO';
          } else if (value < 0.1) {
              color = '#f7931a';  // Neutro
              label = 'EST√ÅVEL';
          } else if (value < 0.4) {
              color = '#ff2a55';  // Expans√£o leve
              label = 'EXPANDINDO';
          } else {
              color = '#ff0062';  // Expans√£o forte
              label = 'EXPLOSIVO';
          }
      } else {
          // Para volatilidade (0-100)
          gaugeValue = value / 100;
          displayValue = value.toFixed(1);
          
          if (value < 30) {
              color = '#00ff9d';  // Baixa
              label = 'BAIXA';
          } else if (value < 60) {
              color = '#f7931a';  // Moderada
              label = 'MODERADA';
          } else {
              color = '#ff2a55';  // Alta
              label = 'ALTA';
          }
      }
      
      // Fundo do gauge
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, Math.PI * 0.8, Math.PI * 2.2);
      ctx.strokeStyle = '#1a243f';
      ctx.lineWidth = 10;
      ctx.stroke();
      
      // Arco animado (com efeito de crescimento)
      const startAngle = Math.PI * 0.8;
      const targetAngle = startAngle + (Math.PI * 1.4 * gaugeValue);
      
      // Suavizar a anima√ß√£o
      const now = Date.now();
      const pulse = Math.sin(now / 800) * 0.03 + 1;
      const currentAngle = startAngle + (Math.PI * 1.4 * gaugeValue * pulse);
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, startAngle, currentAngle);
      ctx.strokeStyle = color;
      ctx.lineWidth = 10;
      ctx.lineCap = 'round';
      
      // Efeito de brilho para valores extremos
      if (Math.abs(gaugeValue - 0.5) > 0.3) {
          ctx.shadowColor = color;
          ctx.shadowBlur = 15;
      }
      
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Marcador com tremula√ß√£o natural
      const tremor = Math.sin(now / 300) * 0.5;
      const markerAngle = currentAngle + tremor * 0.02;
      const markerLength = radius * 0.8;
      const markerX = centerX + Math.cos(markerAngle) * markerLength;
      const markerY = centerY + Math.sin(markerAngle) * markerLength;
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(markerX, markerY);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Valor central com efeito de pulso
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 16px var(--font-mono)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Efeito de pulso para valores extremos
      const textScale = (Math.abs(gaugeValue - 0.5) > 0.3) ? 
          (1 + Math.sin(now / 500) * 0.05) : 1;
      
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.scale(textScale, textScale);
      ctx.translate(-centerX, -centerY);
      ctx.fillText(displayValue, centerX, centerY);
      ctx.restore();
      
      // Label
      ctx.fillStyle = color;
      ctx.font = 'bold 11px var(--font-main)';
      ctx.fillText(label, centerX, centerY + 25);
      
      // Ponto central com brilho
      ctx.beginPath();
      ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
  }

  // 6. DESENHAR GR√ÅFICO DE ACELERA√á√ÉO DIN√ÇMICO
  function drawDynamicAccelerationChart() {
      const canvas = $('accelerationHistoryChart');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const now = Date.now();
      
      ctx.clearRect(0, 0, width, height);
      
      // Garantir que temos dados
      if (accelerationHistory.length < 5) {
          // Inicializar com dados sint√©ticos
          for (let i = 0; i < 20; i++) {
              const timeVar = Math.sin(now / 8000 + i * 0.3) * 0.6;
              accelerationHistory.push(timeVar);
          }
      }
      
      const history = accelerationHistory.slice(-20);
      const minVal = Math.min(...history, -0.8);
      const maxVal = Math.max(...history, 0.8);
      const range = maxVal - minVal || 1.6;
      
      // √Årea de fundo com gradiente
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgba(255, 42, 85, 0.1)');    // Expans√£o
      gradient.addColorStop(0.5, 'rgba(247, 147, 26, 0.1)'); // Neutro
      gradient.addColorStop(1, 'rgba(0, 180, 216, 0.1)');    // Compress√£o
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      // Linha zero
      const zeroY = height * 0.5;
      ctx.beginPath();
      ctx.moveTo(0, zeroY);
      ctx.lineTo(width, zeroY);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 3]);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Linha da acelera√ß√£o com anima√ß√£o
      ctx.beginPath();
      history.forEach((value, index) => {
          const x = (index / (history.length - 1)) * width;
          const normalizedY = (value - minVal) / range;
          const y = height - (normalizedY * height);
          
          // Suavizar com onda temporal
          const wave = Math.sin(now / 2000 + index * 0.5) * 0.5;
          const smoothY = y + wave;
          
          if (index === 0) {
              ctx.moveTo(x, smoothY);
          } else {
              // Curva suave
              const prevX = ((index - 1) / (history.length - 1)) * width;
              const prevY = height - ((history[index-1] - minVal) / range * height);
              const cpx1 = prevX + (x - prevX) * 0.3;
              const cpy1 = prevY;
              const cpx2 = prevX + (x - prevX) * 0.7;
              const cpy2 = smoothY;
              
              ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, smoothY);
          }
      });
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.lineJoin = 'round';
      ctx.stroke();
      
      // Pontos de dados
      history.forEach((value, index) => {
          const x = (index / (history.length - 1)) * width;
          const normalizedY = (value - minVal) / range;
          const y = height - (normalizedY * height);
          
          // Cor baseada no valor
          let pointColor;
          if (value < -0.3) {
              pointColor = '#00b4d8';
          } else if (value < 0.3) {
              pointColor = '#f7931a';
          } else {
              pointColor = '#ff2a55';
          }
          
          // Efeito de pulso para pontos significativos
          const isSignificant = Math.abs(value) > 0.4;
          const pulseSize = isSignificant ? 
              (4 + Math.sin(now / 400 + index) * 2) : 3;
          
          ctx.beginPath();
          ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
          ctx.fillStyle = pointColor;
          
          if (isSignificant) {
              ctx.shadowColor = pointColor;
              ctx.shadowBlur = 10;
          }
          
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Borda branca
          ctx.beginPath();
          ctx.arc(x, y, pulseSize * 0.7, 0, Math.PI * 2);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
      });
      
      // Valor atual destacado
      if (history.length > 0) {
          const lastValue = history[history.length - 1];
          const x = width - 8;
          const normalizedY = (lastValue - minVal) / range;
          const y = height - (normalizedY * height);
          
          // Pulsar forte para valores extremos
          const isExtreme = Math.abs(lastValue) > 0.5;
          const pulseIntensity = isExtreme ? 
              (8 + Math.sin(now / 300) * 4) : (6 + Math.sin(now / 500) * 2);
          
          ctx.beginPath();
          ctx.arc(x, y, pulseIntensity, 0, Math.PI * 2);
          ctx.fillStyle = lastValue < -0.3 ? '#00b4d8' : lastValue < 0.3 ? '#f7931a' : '#ff2a55';
          
          if (isExtreme) {
              ctx.shadowColor = ctx.fillStyle;
              ctx.shadowBlur = 20;
          }
          
          ctx.fill();
          ctx.shadowBlur = 0;
          
          ctx.beginPath();
          ctx.arc(x, y, pulseIntensity * 0.5, 0, Math.PI * 2);
          ctx.fillStyle = '#ffffff';
          ctx.fill();
          
          // Valor num√©rico
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 12px var(--font-mono)';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(lastValue.toFixed(2), x - 10, y - 12);
      }
      
      // Legenda animada
      ctx.fillStyle = '#f7931a';
      ctx.font = 'bold 10px var(--font-mono)';
      ctx.textAlign = 'left';
      
      const titles = [
          'ACELERA√á√ÉO DA VOLATILIDADE',
          'TEND√äNCIA DIN√ÇMICA',
          'MOMENTO DO MERCADO',
          'ENERGIA ACUMULADA'
      ];
      const titleIndex = Math.floor((now / 4000) % titles.length);
      
      ctx.fillText(titles[titleIndex], 10, 16);
      
      ctx.fillStyle = '#637599';
      ctx.font = '9px var(--font-main)';
      ctx.fillText('Negativo = compress√£o | Positivo = expans√£o', 10, 28);
  }

  // 7. ATUALIZAR SISTEMA DE ACELERA√á√ÉO
  function updateAccelerationSystem() {
      try {
          // Calcular valores
          currentVolatility = calculateRealTimeVolatility(KLINES_VISUAL);
          currentAcceleration = calculateRealTimeAcceleration(KLINES_VISUAL);
          accelerationPrecision = calculateRealTimePrecision(
              currentAcceleration, 
              currentVolatility, 
              CURRENT_SIGMA
          );
          
          // Adicionar √† hist√≥ria
          accelerationHistory.push(currentAcceleration);
          if (accelerationHistory.length > MAX_HISTORY) {
              accelerationHistory.shift();
          }
          
          // Atualizar interface
          updateAccelerationInterface();
          
          // Log para debug (apenas 10% das vezes)
          if (Math.random() < 0.1) {
              console.log(`üîÑ Acelera√ß√£o: ${currentAcceleration.toFixed(3)}, Vol: ${currentVolatility.toFixed(1)}, Prec: ${accelerationPrecision.toFixed(1)}%`);
          }
          
          lastAccelerationData = {
              acceleration: currentAcceleration,
              volatility: currentVolatility,
              precision: accelerationPrecision,
              timestamp: Date.now()
          };
          
      } catch (error) {
          console.warn('Erro no sistema de acelera√ß√£o:', error);
      }
  }

  // 8. ATUALIZAR INTERFACE DE ACELERA√á√ÉO
  function updateAccelerationInterface() {
      // Atualizar gauges com oscila√ß√£o
      drawDynamicGauge('volatilityGauge', currentVolatility, 'VOLATILIDADE', false);
      drawDynamicGauge('accelerationGauge', currentAcceleration, 'ACELERA√á√ÉO', true);
      
      // Atualizar valores num√©ricos
      const volatilityValue = $('volatilityValue');
      const accelerationValue = $('accelerationValue');
      
      if (volatilityValue) {
          volatilityValue.textContent = currentVolatility.toFixed(1);
          
          // Cor din√¢mica
          if (currentVolatility < 30) {
              volatilityValue.className = 'gauge-value vol-low';
              volatilityValue.style.color = '#00ff9d';
          } else if (currentVolatility < 60) {
              volatilityValue.className = 'gauge-value vol-med';
              volatilityValue.style.color = '#f7931a';
          } else {
              volatilityValue.className = 'gauge-value vol-high';
              volatilityValue.style.color = '#ff2a55';
          }
      }
      
      if (accelerationValue) {
          accelerationValue.textContent = currentAcceleration.toFixed(2);
          
          // Cor e classe din√¢mica
          if (currentAcceleration < -0.4) {
              accelerationValue.className = 'gauge-value acc-neg-high';
              accelerationValue.style.color = '#00b4d8';
          } else if (currentAcceleration < -0.1) {
              accelerationValue.className = 'gauge-value acc-neg';
              accelerationValue.style.color = '#00ff9d';
          } else if (currentAcceleration < 0.1) {
              accelerationValue.className = 'gauge-value acc-neutral';
              accelerationValue.style.color = '#f7931a';
          } else if (currentAcceleration < 0.4) {
              accelerationValue.className = 'gauge-value acc-pos';
              accelerationValue.style.color = '#ff2a55';
          } else {
              accelerationValue.className = 'gauge-value acc-pos-high';
              accelerationValue.style.color = '#ff0062';
          }
      }
      
      // Atualizar gr√°fico
      drawDynamicAccelerationChart();
      
      // Detectar regime
      const regime = detectDynamicRegime(currentAcceleration, currentVolatility, CURRENT_SIGMA);
      
      // Atualizar regime
      const regimeElement = $('currentAccelerationRegime');
      const actionElement = $('accelerationAction');
      
      if (regimeElement) {
          regimeElement.textContent = regime.name;
          regimeElement.style.color = regime.color;
          
          // Efeito de pulso para regimes importantes
          if (regime.confidence > 75) {
              const pulse = 0.7 + Math.sin(Date.now() / 600) * 0.3;
              regimeElement.style.opacity = pulse;
          } else {
              regimeElement.style.opacity = 1;
          }
      }
      
      if (actionElement) {
          actionElement.textContent = regime.action;
          actionElement.style.color = regime.color;
      }
      
      // Gerar alertas
      const alerts = generateAccelerationAlerts(currentAcceleration, currentVolatility, CURRENT_SIGMA);
      updateAccelerationAlerts(alerts);
      
      // Atualizar informa√ß√µes
      updateAccelerationInfo(currentAcceleration, currentVolatility, accelerationPrecision, regime);
  }

  // 9. ATUALIZAR INFORMA√á√ïES DE ACELERA√á√ÉO
  function updateAccelerationInfo(acceleration, volatility, precision, regime) {
      const container = $('acceleration-info-container');
      if (!container) return;
      
      // Calcular lead time din√¢mico
      let leadTime;
      if (acceleration < -0.5) {
          leadTime = '1-2 candles';
      } else if (acceleration < -0.2) {
          leadTime = '2-3 candles';
      } else if (acceleration < 0.2) {
          leadTime = '3-5 candles';
      } else if (acceleration < 0.5) {
          leadTime = '1-2 candles';
      } else {
          leadTime = 'IMEDIATO';
      }
      
      // Cor da precis√£o
      const precisionColor = precision > 80 ? '#00ff9d' : 
                            precision > 60 ? '#f7931a' : '#ff2a55';
      
      const now = Date.now();
      const html = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;">
              <div style="background: linear-gradient(135deg, rgba(4,8,15,0.8), rgba(4,8,15,0.5)); padding: 6px; border-radius: 4px; border: 1px solid ${regime.color}40; box-shadow: 0 0 10px ${regime.color}20;">
                  <span style="font-size: 9px; color: var(--text-muted);">Regime</span><br>
                  <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: ${regime.color};">${regime.name}</span>
              </div>
              <div style="background: linear-gradient(135deg, rgba(4,8,15,0.8), rgba(4,8,15,0.5)); padding: 6px; border-radius: 4px; border: 1px solid ${precisionColor}40; box-shadow: 0 0 10px ${precisionColor}20;">
                  <span style="font-size: 9px; color: var(--text-muted);">Precis√£o</span><br>
                  <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: ${precisionColor};">${precision.toFixed(1)}%</span>
              </div>
              <div style="background: linear-gradient(135deg, rgba(4,8,15,0.8), rgba(4,8,15,0.5)); padding: 6px; border-radius: 4px; border: 1px solid #1a243f;">
                  <span style="font-size: 9px; color: var(--text-muted);">Lead Time</span><br>
                  <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600;">${leadTime}</span>
              </div>
              <div style="background: linear-gradient(135deg, rgba(4,8,15,0.8), rgba(4,8,15,0.5)); padding: 6px; border-radius: 4px; border: 1px solid ${regime.color}40;">
                  <span style="font-size: 9px; color: var(--text-muted);">Confian√ßa</span><br>
                  <span style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: ${regime.color};">${regime.confidence}%</span>
              </div>
          </div>
      `;
      
      container.innerHTML = html;
  }

  // 10. GERAR ALERTAS DIN√ÇMICOS
  function generateAccelerationAlerts(acceleration, volatility, sigma) {
      const alerts = [];
      const now = Date.now();
      const timeStr = `${new Date(now).getHours().toString().padStart(2, '0')}:${new Date(now).getMinutes().toString().padStart(2, '0')}`;
      
      // Alerta de COMPRESS√ÉO EXTREMA
      if (acceleration < -0.5 && volatility < 35) {
          alerts.push({
              type: 'HIGH_PROB',
              title: 'üí• COMPRESS√ÉO EXTREMA',
              description: `Acelera√ß√£o: ${acceleration.toFixed(2)} | Vol: ${volatility.toFixed(1)} | Explos√£o iminente`,
              probability: 85 + Math.sin(now/2000)*5,
              icon: 'üí•',
              color: '#00b4d8',
              priority: 1
          });
      }
      
      // Alerta de EXPANS√ÉO ACELERADA
      if (acceleration > 0.4 && acceleration < 0.7) {
          alerts.push({
              type: 'WARNING',
              title: 'üìà VOL EM EXPANS√ÉO',
              description: `Acelera√ß√£o: ${acceleration.toFixed(2)} | Momentum positivo crescente`,
              probability: 75 + Math.sin(now/2500)*5,
              icon: 'üìà',
              color: '#ff2a55',
              priority: 2
          });
      }
      
      // Alerta de PICO DE ACELERA√á√ÉO
      if (acceleration > 0.7) {
          alerts.push({
              type: 'CRITICAL',
              title: '‚ö†Ô∏è ACELERA√á√ÉO EXPLOSIVA',
              description: `Acelera√ß√£o: ${acceleration.toFixed(2)} | Movimento violento esperado`,
              probability: 90 + Math.sin(now/1500)*5,
              icon: '‚ö†Ô∏è',
              color: '#ff0062',
              priority: 1
          });
      }
      
      // Alerta de REVERS√ÉO
      if (sigma < -1.5 && acceleration > 0.2) {
          alerts.push({
              type: 'HIGH_PROB',
              title: 'üîÑ REVERS√ÉO DE BAIXA',
              description: `Sigma: ${sigma.toFixed(1)} | Acelera√ß√£o: ${acceleration.toFixed(2)} | Entrada agressiva`,
              probability: 80 + Math.sin(now/1800)*5,
              icon: 'üîÑ',
              color: '#00ff9d',
              priority: 1
          });
      }
      
      // Alerta de NEUTRALIDADE COM PRECIS√ÉO ALTA
      if (Math.abs(acceleration) < 0.1 && accelerationPrecision > 70) {
          alerts.push({
              type: 'INFO',
              title: '‚öñÔ∏è MERCADO EST√ÅVEL',
              description: `Acelera√ß√£o neutra | Precis√£o: ${accelerationPrecision.toFixed(1)}% | Aguardar gatilho`,
              probability: 65 + Math.sin(now/3000)*5,
              icon: '‚öñÔ∏è',
              color: '#f7931a',
              priority: 3
          });
      }
      
      return alerts;
  }

  // 11. ATUALIZAR ALERTAS
  function updateAccelerationAlerts(alerts) {
      const alertsContainer = $('accelerationAlertsContainer');
      if (!alertsContainer) return;
      
      if (alerts.length === 0) {
          const analyzing = [
              'Monitorando acelera√ß√£o...',
              'Aguardando sinais...',
              'Analisando tend√™ncias...',
              'Processando dados...'
          ];
          const idx = Math.floor(Date.now() / 4000 % analyzing.length);
          
          alertsContainer.innerHTML = `
              <div class="alert-item">
                  <div class="alert-icon info">üìä</div>
                  <div class="alert-content">
                      <div class="alert-title">SEM ALERTAS ATIVOS</div>
                      <div class="alert-desc">${analyzing[idx]}</div>
                  </div>
                  <div class="alert-time">‚Äî</div>
              </div>
          `;
          return;
      }
      
      let html = '';
      const now = new Date();
      const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
      
      alerts.slice(0, 3).forEach(alert => {
          const iconClass = alert.type === 'CRITICAL' ? 'critical' : 
                          alert.type === 'HIGH_PROB' ? 'high-prob' : 
                          alert.type === 'WARNING' ? 'warning' : 'info';
          
          const glowStyle = alert.type === 'CRITICAL' ? 'style="animation: pulse-alert 1s infinite;"' : 
                           alert.type === 'HIGH_PROB' ? 'style="animation: pulse 2s infinite;"' : '';
          
          html += `
              <div class="alert-item" ${glowStyle}>
                  <div class="alert-icon ${iconClass}">${alert.icon}</div>
                  <div class="alert-content">
                      <div class="alert-title" style="color: ${alert.color}">${alert.title}</div>
                      <div class="alert-desc">${alert.description}</div>
                  </div>
                  <div class="alert-time">${timeStr}</div>
              </div>
          `;
      });
      
      alertsContainer.innerHTML = html;
  }

  // 12. INICIAR ATUALIZA√á√ïES AUTOM√ÅTICAS
  function startAccelerationUpdates() {
      // Parar qualquer intervalo existente
      if (accelerationUpdateInterval) {
          clearInterval(accelerationUpdateInterval);
      }
      
      // Iniciar imediatamente
      updateAccelerationSystem();
      
      // Configurar intervalo autom√°tico (1.5 segundos)
      accelerationUpdateInterval = setInterval(() => {
          updateAccelerationSystem();
      }, 1500);
      
      console.log('üöÄ Sistema de acelera√ß√£o iniciado (autom√°tico)');
  }

  // 13. FUN√á√ÉO PARA ATUALIZA√á√ÉO MANUAL (bot√£o)
  function forceAccelerationUpdate() {
      if (lastAccelerationData) {
          const now = Date.now();
          const age = now - lastAccelerationData.timestamp;
          
          if (age < 500) { // Menos de 0.5 segundos
              console.log('‚è±Ô∏è  Dados muito recentes, pulando atualiza√ß√£o...');
              return;
          }
      }
      
      console.log('üîÑ For√ßando atualiza√ß√£o manual...');
      updateAccelerationSystem();
      
      // Feedback visual
      const button = $('refreshAcceleration');
      if (button) {
          button.style.background = 'linear-gradient(135deg, #00ff9d, #00b4d8)';
          button.textContent = 'ATUALIZADO!';
          
          setTimeout(() => {
              button.style.background = 'linear-gradient(135deg, #f7931a, #ff2a55)';
              button.textContent = 'Atualizar';
          }, 1000);
      }
  }

  // 14. RESETAR SISTEMA
  function resetAccelerationSystem() {
      accelerationHistory = [];
      lastAccelerationData = null;
      accelerationPrecision = 50;
      
      // Recriar dados iniciais
      const now = Date.now();
      for (let i = 0; i < 20; i++) {
          const timeVar = Math.sin(now / 8000 + i * 0.3) * 0.6;
          accelerationHistory.push(timeVar);
      }
      
      updateAccelerationInterface();
      console.log('üîÑ Sistema de acelera√ß√£o resetado');
  }

  // 15. INICIALIZAR GAUGES
  function initAccelerationGauges() {
      const volatilityCanvas = $('volatilityGauge');
      const accelerationCanvas = $('accelerationGauge');
      const historyCanvas = $('accelerationHistoryChart');
      
      if (volatilityCanvas && accelerationCanvas) {
          const containerWidth = volatilityCanvas.parentElement ? volatilityCanvas.parentElement.clientWidth : 180;
          const size = Math.min(containerWidth, 180);
          
          volatilityCanvas.width = size;
          volatilityCanvas.height = 140;
          accelerationCanvas.width = size;
          accelerationCanvas.height = 140;
          
          // Desenhar gauges iniciais
          drawDynamicGauge('volatilityGauge', 50, 'VOLATILIDADE', false);
          drawDynamicGauge('accelerationGauge', 0, 'ACELERA√á√ÉO', true);
      }
      
      if (historyCanvas) {
          const historyContainer = historyCanvas.parentElement;
          if (historyContainer) {
              historyCanvas.width = historyContainer.clientWidth || 300;
          } else {
              historyCanvas.width = 300;
          }
          historyCanvas.height = 80;
          
          drawDynamicAccelerationChart();
      }
  }

  // =================================================================
  // ============ FUN√á√ïES DE ATUALIZA√á√ÉO DE PRE√áO ============
  // =================================================================
  
  async function updateLivePrice() {
    const symbol = $('symbol').value;
    const priceEl = $('px-current');
    const chgEl = $('px-chg');
    try {
      let apiSymbol = 'BTCBRL';
      let invert = false;
      if (symbol === 'BRLBTC') {
        apiSymbol = 'BTCBRL';
        invert = true;
      }
      
      const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${apiSymbol}`);
      const data = await response.json();
      let currentPrice = parseFloat(data.price);
      if (invert && isFinite(currentPrice) && currentPrice !== 0) {
        currentPrice = 1 / currentPrice;
      }
      if (isNaN(currentPrice)) throw new Error('Pre√ßo Inv√°lido');
      livePrice = currentPrice;

      if (symbol === 'BTCBRL') PX_BTC_BRL = currentPrice;
      
      let priceText;
      if (symbol.endsWith('BRL') || symbol === 'BRLBTC') {
        priceText = currentPrice.toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL',
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        });
      } else {
        priceText = currentPrice.toLocaleString('en-US', {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 4,
          maximumFractionDigits: 4
        });
      }
      
      if (priceEl) priceEl.textContent = priceText;

      const base = (dailyOpenRef !== null && Number.isFinite(dailyOpenRef))
        ? dailyOpenRef
        : lastClose;

      if (chgEl) {
        if (base !== null && Number.isFinite(base)) {
          const diff = currentPrice - base;
          const diffPct = (diff / base) * 100;
          chgEl.textContent = diff >= 0
            ? `+${diffPct.toFixed(2)}%`
            : `${diffPct.toFixed(2)}%`;
          chgEl.className = diff >= 0 ? 'up' : 'dn';
        } else {
          chgEl.textContent = '‚Äî';
          chgEl.className = '';
        }
      }

      if (CHART_MAIN) {
        CHART_MAIN.update('none');
      }

      try {
        calcRebalanceRealTime();
        
        if (BB_BASIS && BB_BASIS.length > 0 && BB_STD && BB_STD.length > 0) {
          const sigma = updateHeatmap({ basis: BB_BASIS, std: BB_STD }, currentPrice);
          updateRecommendation(sigma, currentPrice, { basis: BB_BASIS, std: BB_STD });
        } else {
          updateRecommendation(0, currentPrice, { basis: [], std: [] });
        }
        
        forceAccelerationUpdate();
        
      } catch (e) {
        console.warn('Falha ao recalcular pain√©is em tempo real:', e);
      }

    } catch (error) {
      console.warn('Falha ao atualizar pre√ßo em tempo real:', error);
      livePrice = null;
      if (chgEl) {
        chgEl.textContent = 'ERRO';
        chgEl.className = 'dn';
      }
    }
  }

  // =================================================================
  // ============ FUN√á√ÉO PRINCIPAL DE ATUALIZA√á√ÉO ============
  // =================================================================
  
  async function update() {
    if (DEBOUNCE_TIMER) clearTimeout(DEBOUNCE_TIMER);
    DEBOUNCE_TIMER = setTimeout(async () => {
      const targetCandles = parseInt($('candlesCount').value) || 5000;
      setStatus(`SINCRONIZANDO C++ ULTRA AGRESSIVA (${targetCandles} CANDLES - TODOS OS SINAIS)...`);
      try {
        const pair = $('symbol').value;
        const tf = $('tf').value;
        
        const updateElementText = (id, text) => {
          const el = $(id);
          if (el) el.textContent = text;
        };
        
        updateElementText('candles-count', targetCandles);
        updateElementText('candles-count-label', targetCandles);
        updateElementText('candles-count-small', targetCandles);
        
        const candlesCountSidebar = $('candlesCountSidebar');
        if (candlesCountSidebar) {
          candlesCountSidebar.value = targetCandles;
        }
        
        let apiSymbol = 'BTCBRL';
        let invert = false;
        if (pair === 'BRLBTC') {
          apiSymbol = 'BTCBRL';
          invert = true;
        }
        
        KLINES_VISUAL = await fetchKlines(apiSymbol, tf, targetCandles);
        
        if (invert && KLINES_VISUAL && KLINES_VISUAL.length) {
          KLINES_VISUAL = KLINES_VISUAL.map(k => ({
            ...k,
            o: k.o ? 1 / k.o : k.o,
            h: k.h ? 1 / k.h : k.h,
            l: k.l ? 1 / k.l : k.l,
            c: k.c ? 1 / k.c : k.c
          }));
        }
        
        lastClose = KLINES_VISUAL.length >= 2 ? 
          KLINES_VISUAL[KLINES_VISUAL.length - 2].c : 
          KLINES_VISUAL.length > 0 ? KLINES_VISUAL[KLINES_VISUAL.length - 1].o : null;
        
        KLINES_BTC = KLINES_VISUAL;
        
        await fetchPrices();
        
        if (PRICE_POLL_TIMER) clearInterval(PRICE_POLL_TIMER);
        await updateLivePrice();
        PRICE_POLL_TIMER = setInterval(updateLivePrice, 10000);
        
        if (KLINES_VISUAL.length) {
          console.log(`‚úÖ ${KLINES_VISUAL.length} candles carregados para an√°lise (alvo: ${targetCandles}) - Processando TODOS os sinais`);
          
          const kmul = parseFloat($('atrMul').value);
          const closes = KLINES_VISUAL.map(k => k.c);
          const bb = bb204(closes);
          const atrArr = atr(KLINES_VISUAL, 14);
          
          const sigs = processSignalsCPP(KLINES_VISUAL, bb, atrArr, kmul);
          
          updateSignalDisplay(sigs.allSignals);
          
          const xy = (arr) => KLINES_VISUAL.map((k, i) => ({
            x: k.x,
            y: arr[i]
          })).filter(p => !isNaN(p.y));
          
          const ds = CHART_MAIN.data.datasets;
          ds[0].data = xy(bb.u30);
          ds[1].data = xy(bb.l30);
          ds[2].data = xy(bb.u25);
          ds[3].data = xy(bb.l25);
          ds[4].data = xy(bb.u20);
          ds[5].data = xy(bb.l20);
          ds[6].data = xy(bb.u15);
          ds[7].data = xy(bb.l15);
          ds[8].data = xy(bb.u10);
          ds[9].data = xy(bb.l10);
          ds[10].data = xy(bb.u05);
          ds[11].data = xy(bb.l05);
          ds[12].data = xy(bb.basis);
          
          ds.splice(13, ds.length - 13);
          
          const addSig = (key, color, up, size) => {
            if (sigs.plotList[key] && sigs.plotList[key].length) {
              ds.push({
                type: 'scatter',
                showLine: false,
                data: sigs.plotList[key],
                label: key,
                borderColor: color,
                backgroundColor: color,
                pointStyle: 'triangle',
                pointRadius: size,
                pointHoverRadius: size + 1,
                pointRotation: up ? 0 : 180
              });
            }
          };
          
          addSig('C05', '#6cfca6', true, 4);
          addSig('C10', '#27e46d', true, 5);
          addSig('C15', '#00c7a7', true, 6);
          addSig('C20', '#00a8ff', true, 7);
          addSig('C25', '#0062ff', true, 8);
          addSig('C30', '#0011ff', true, 9);
          
          addSig('V10', '#ff8b8b', false, 5);
          addSig('V15', '#ff5757', false, 6);
          addSig('V20', '#ff2a55', false, 7);
          addSig('V25', '#ff0062', false, 8);
          addSig('V30', '#ff0000', false, 9);
          
          CHART_MAIN.$candles = KLINES_VISUAL;
          CHART_MAIN.update();
          
          calcRebalanceRealTime();
          
          initAccelerationGauges();
          
          if (livePrice) {
            const sigma = updateHeatmap(bb, livePrice);
            updateRecommendation(sigma, livePrice, bb);
          } else {
            const lastPrice = KLINES_VISUAL[KLINES_VISUAL.length - 1].c;
            const sigma = updateHeatmap(bb, lastPrice);
            updateRecommendation(sigma, lastPrice, bb);
          }
          
          forceAccelerationUpdate();
          
          setStatus(`C++ ULTRA AGRESSIVA ATIVA - ${KLINES_VISUAL.length}/${targetCandles} CANDLES - TODOS OS ${sigs.allSignals.length} SINAIS`);
        } else {
          setStatus("ERRO: Nenhum dado recebido da API", true);
        }
      } catch (e) {
        console.error("Erro na estrat√©gia C++:", e);
        setStatus("ERRO: " + (e.message || 'Falha desconhecida'), true);
      }
    }, 100);
  }

  // =================================================================
  // ============ PLUGINS DO GR√ÅFICO ============
  // =================================================================
  
  const CandlePlugin = {
    id: 'customCandle',
    beforeDatasetsDraw(chart) {
      const { ctx, scales: { x, y } } = chart;
      const data = chart.$candles || []; 
      if (!data.length) return;
      const up='#00ff9d', down='#ff2a55', wick='#cfd9ff';
      const step = data.length > 1 ? x.getPixelForValue(data[1].x) - x.getPixelForValue(data[0].x) : 8;
      const bw = Math.max(3, Math.min(12, Math.abs(step * 0.6)));
      const ww = Math.max(1, Math.min(3, Math.abs(step * 0.12)));
      ctx.save();
      const maxIdx = data.length - (livePrice ? 1 : 0); 
      for(let i=0; i<maxIdx; i++){
        const d = data[i];
        const cx=x.getPixelForValue(d.x), yO=y.getPixelForValue(d.o), yH=y.getPixelForValue(d.h), yL=y.getPixelForValue(d.l), yC=y.getPixelForValue(d.c);
        const isUp=d.c>=d.o;
        ctx.strokeStyle=wick;
        ctx.lineWidth=ww;
        ctx.beginPath(); ctx.moveTo(cx, yH); ctx.lineTo(cx, yL); ctx.stroke();
        ctx.fillStyle=isUp?up:down;
        const top=Math.min(yO,yC), bot=Math.max(yO,yC);
        ctx.fillRect(cx-bw/2, top, bw, Math.max(1, bot-top));
      }
      if (livePrice && data.length > 0) {
          const d = data[data.length - 1];
          const cx=x.getPixelForValue(d.x);
          const yLive = y.getPixelForValue(livePrice);
          const yOpen = y.getPixelForValue(d.o);
          const yHigh = y.getPixelForValue(d.h);
          const yLow = y.getPixelForValue(d.l);
          const isUp = livePrice >= d.o;
          const liveColor = isUp ? up : down;
          ctx.strokeStyle = wick;
          ctx.lineWidth = ww;
          ctx.beginPath(); 
          ctx.moveTo(cx, yHigh); ctx.lineTo(cx, yLow); 
          ctx.stroke();
          const bodyTop = Math.min(yLive, yOpen);
          const bodyBot = Math.max(yLive, yOpen);
          ctx.fillStyle = liveColor;
          ctx.fillRect(cx - bw / 2, bodyTop, bw, Math.max(1, bodyBot - bodyTop));
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 1;
          ctx.strokeRect(cx - bw / 2, bodyTop, bw, Math.max(1, bodyBot - bodyTop));
      }
      ctx.restore();
    }
  };
  
  const YAxisIndicatorPlugin = {
    id: 'yAxisIndicators',
    afterDraw(chart) {
        const { ctx, scales: { x, y } } = chart;
        const datasets = chart.data.datasets;
        if (!livePrice || !KLINES_VISUAL.length) return; 
        ctx.save();
        ctx.font = 'bold 14px var(--font-mono)'; 
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const rightEdge = y.right;
        const buyColor = getComputedStyle(document.documentElement).getPropertyValue('--buy').trim() || '#00ff9d';
        const sellColor = getComputedStyle(document.documentElement).getPropertyValue('--sell').trim() || '#ff2a55';
        const priceScale = y.max;
        const precision = priceScale > 1000 ? 2 : (priceScale > 10 ? 3 : 4);
        for (let i = 0; i < 7; i++) {
            const ds = datasets[i];
            const data = ds.data;
            if (!data || data.length === 0) continue;
            const lastPoint = data[data.length - 1];
            const value = lastPoint ? lastPoint.y : NaN;
            if (!isFinite(value)) continue;
            const pixelY = y.getPixelForValue(value);
            const color = ds.borderColor; 
            const labelText = value.toFixed(precision);
            const textWidth = ctx.measureText(labelText).width;
            const boxPadding = 4;
            const boxHeight = 18;
            ctx.fillStyle = color;
            ctx.fillRect(rightEdge, pixelY - boxHeight / 2, textWidth + boxPadding * 2, boxHeight);
            ctx.fillStyle = 'black'; 
            ctx.fillText(labelText, rightEdge + boxPadding, pixelY);
        }
        const currentClose = livePrice;
        const open = KLINES_VISUAL[KLINES_VISUAL.length - 1].o;
        const isUp = currentClose >= open;
        const color = isUp ? buyColor : sellColor; 
        const pixelY = y.getPixelForValue(currentClose);
        const labelText = currentClose.toFixed(precision);
        const textWidth = ctx.measureText(labelText).width;
        const boxPadding = 4;
        const boxHeight = 18;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x.right - 10, pixelY);
        ctx.lineTo(rightEdge, pixelY);
        ctx.stroke();
        ctx.fillStyle = color;
        ctx.fillRect(rightEdge, pixelY - boxHeight / 2, textWidth + boxPadding * 2, boxHeight);
        ctx.fillStyle = isUp ? 'black' : 'white';
        ctx.font = 'bold 14px var(--font-mono)';
        ctx.fillText(labelText, rightEdge + boxPadding, pixelY);
        ctx.restore();
    }
  };
  
  Chart.register(CandlePlugin, YAxisIndicatorPlugin);
  
  // =================================================================
  // ============ INICIALIZA√á√ÉO DO GR√ÅFICO ============
  // =================================================================
  
  function initChart() {
    const ctx = $('chart').getContext('2d');
    CHART_MAIN = new Chart(ctx, {
        type: 'line',
        data: { datasets: [
            // 3œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,255,255,0.20)', borderWidth:1, label:'U3.0' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,255,255,0.20)', borderWidth:1, label:'L3.0' },
            // 2.5œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(0,255,157,0.20)', borderWidth:1, label:'U2.5' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,42,85,0.20)', borderWidth:1, label:'L2.5' },
            // 2.0œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(0,255,157,0.16)', borderWidth:1, label:'U2.0' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,42,85,0.16)', borderWidth:1, label:'L2.0' },
            // 1.5œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(0,255,157,0.14)', borderWidth:1, label:'U1.5' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,42,85,0.14)', borderWidth:1, label:'L1.5' },
            // 1.0œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(0,255,157,0.12)', borderWidth:1, label:'U1.0' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,42,85,0.12)', borderWidth:1, label:'L1.0' },
            // 0.5œÉ
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(0,255,157,0.10)', borderWidth:1, label:'U0.5' },
            { data: [], type:'line', pointRadius:0, borderColor:'rgba(255,42,85,0.10)', borderWidth:1, label:'L0.5' },
            // Base
            { label:'Basis', data:[], type:'line', pointRadius:0, borderColor:'#f0ad4e', borderWidth:1 },
        ]}, 
        options: { 
          responsive:true, maintainAspectRatio:false, 
          plugins:{
              legend:{display:false}, 
              tooltip:{ 
                   enabled: true,
                   mode: 'nearest',
                   intersect: true,
                   filter: (ctx) => {
                     const label = ctx.dataset.label || '';
                     return label.startsWith('C') || label.startsWith('V');
                   },
                   callbacks: {
                       label: (context) => {
                           const t = context.dataset.label || '';
                           return TOOLTIP_MAP_CPP[t] || t;
                       }
                   }
              },
              zoom:{
                  pan: { enabled: true, mode: 'x' },
                  zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
              }
          }, 
          layout: {
              padding: {
                  right: 60 
              }
          },
          scales:{x:{type:'time',grid:{display:false}}, y:{position:'right',grid:{color:'#1e2d4a'}}} 
        },
        plugins: [CandlePlugin, YAxisIndicatorPlugin]
    });
    
    console.log('‚úÖ Gr√°fico inicializado com plugins do tradesystem');
  }

// =================================================================
  // ============ FUN√á√ÉO DE INICIALIZA√á√ÉO PRINCIPAL ============
  // =================================================================
  
  async function init() {
    console.log('üöÄ Inicializando BTC QUANT C++ ULTRA AGRESSIVA TURBO...');
    
    loadBalances();
    
    initChart();
    
    $('symbol').addEventListener('change', update);
    $('tf').addEventListener('change', update);
    $('atrMul').addEventListener('input', update);
    $('riskMode').addEventListener('change', update);
    $('candlesCount').addEventListener('change', update);
    
    const candlesCountSidebar = $('candlesCountSidebar');
    if (candlesCountSidebar) {
      candlesCountSidebar.addEventListener('change', function() {
        const headerSelect = $('candlesCount');
        if (headerSelect) {
          headerSelect.value = this.value;
          update();
        }
      });
    }
    
    $('inSats').addEventListener('input', function() {
      calcRebalanceRealTime();
      saveBalances();
    });
    
    $('inBRL').addEventListener('input', function() {
      calcRebalanceRealTime();
      saveBalances();
    });
    
    const toggleAside = $('toggleAside');
    const aside = document.querySelector('aside');
    const asideClose = $('asideClose');
    
    if (toggleAside && aside) {
      toggleAside.addEventListener('click', () => {
        aside.classList.toggle('aside-open');
      });
    }
    
    if (asideClose && aside) {
      asideClose.addEventListener('click', () => {
        aside.classList.remove('aside-open');
      });
    }
    
    const aiFab = $('aiFab');
    const aiDialog = $('aiDialog');
    const aiClose = $('aiClose');
    
    if (aiFab && aiDialog) {
      aiFab.addEventListener('click', () => {
        if (aiDialog.style.display === 'flex') {
          aiDialog.style.display = 'none';
          aiFab.classList.remove('active');
        } else {
          showCPPTurboAnalysis();
          aiFab.classList.add('active');
        }
      });
      
      aiClose.addEventListener('click', () => {
        aiDialog.style.display = 'none';
        aiFab.classList.remove('active');
      });
      
      document.addEventListener('click', (e) => {
        if (!aiDialog.contains(e.target) && !aiFab.contains(e.target) && aiDialog.style.display === 'flex') {
          aiDialog.style.display = 'none';
          aiFab.classList.remove('active');
        }
      });
    }
    
    const exportSignalsBtn = $('exportSignalsBtn');
    const refreshSignalsBtn = $('refreshSignalsBtn');
    
    if (exportSignalsBtn) {
      exportSignalsBtn.addEventListener('click', exportSignalsToJSON);
    }
    
    if (refreshSignalsBtn) {
      refreshSignalsBtn.addEventListener('click', () => {
        update();
        setStatus('Atualizando sinais do gr√°fico...');
      });
    }
    
    const refreshAccelerationBtn = $('refreshAcceleration');
    const resetAccelerationBtn = $('resetAcceleration');
    
    if (refreshAccelerationBtn) {
      refreshAccelerationBtn.addEventListener('click', forceAccelerationUpdate);
    }
    
    if (resetAccelerationBtn) {
      resetAccelerationBtn.addEventListener('click', resetAccelerationSystem);
    }
    
    await update();
    
    console.log('‚úÖ Sistema BTC QUANT C++ inicializado com sucesso!');
    setStatus('SISTEMA C++ ULTRA AGRESSIVA INICIADO - ACELERA√á√ÉO ATIVA');
    
    initAccelerationGauges();
    
    startAccelerationUpdates();

    // =================================================================
    // ==== NOVO: ATUALIZA√á√ÉO AUTOM√ÅTICA DOS CANDLES (15 MINUTOS) ====
    // =================================================================
    setInterval(async () => {
      console.log('üîÑ Autoupdate: Sincronizando Candles e Sinais...');
      await update(); // Atualiza candles e hist√≥rico
      forceAccelerationUpdate(); // Sincroniza a acelera√ß√£o
      setStatus('SISTEMA ATUALIZADO AUTOMATICAMENTE');
      
      // Volta o texto original ap√≥s 5 segundos
      setTimeout(() => {
        setStatus('SISTEMA C++ ULTRA AGRESSIVA INICIADO - ACELERA√á√ÉO ATIVA');
      }, 5000);
    }, 15 * 60 * 1000); // 15 minutos em milissegundos
  }

  window.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>